<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/icon.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="1  BFS（宽度优先搜索）BFS 的核心思想应该不难理解的，就是把一些问题抽象成图，从一个点开始，向四周开始扩散。一般来说，我们写 BFS 算法都是用「队列」这种数据结构，每次将一个节点周围的所有节点加入队列。 BFS 相对 DFS 的最主要的区别是：BFS 找到的路径一定是最短的，但代价就是空间复杂度比 DFS 大很多，至于为什么，我们后面介绍了框架就很容易看出来了。 本文就由浅入深写两道 B">
<meta property="og:type" content="article">
<meta property="og:title" content="BFS+DFS">
<meta property="og:url" content="https://j-len.github.io/2020/07/18/BFS+DFS+%E5%9B%9E%E6%BA%AF/index.html">
<meta property="og:site_name" content="J Len">
<meta property="og:description" content="1  BFS（宽度优先搜索）BFS 的核心思想应该不难理解的，就是把一些问题抽象成图，从一个点开始，向四周开始扩散。一般来说，我们写 BFS 算法都是用「队列」这种数据结构，每次将一个节点周围的所有节点加入队列。 BFS 相对 DFS 的最主要的区别是：BFS 找到的路径一定是最短的，但代价就是空间复杂度比 DFS 大很多，至于为什么，我们后面介绍了框架就很容易看出来了。 本文就由浅入深写两道 B">
<meta property="og:image" content="https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibkIz0MVqdFibgK5meWHW0A22LMoJu55Q2BIsAtY2cAicGnvmMeyjibqpum44XLBlf5iaCwIIQwkacib4nSklBdyDhQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibkIz0MVqdFibgK5meWHW0A22LMoJu55QH3cqLJFwFg4TIiaRpiasaDknlQDhMBLaxWJKsUzejz4514iciaicTPlHXDQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibkIz0MVqdFibgK5meWHW0A22LMoJu55QnaxXtUnzc3YWR3PpicMwtL2DWEAI7H6lXOQaRqNYJK3Iw4EMs8DkFGg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="c:%5CUsers%5CSean%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200423220008156.png">
<meta property="og:image" content="https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibkIz0MVqdFibgK5meWHW0A22LMoJu55QJg6mpZUWAk3oyibLDgNiaJAC8icl3TIgd6kHGd6ymr0OmACWguIoS6ibYA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibkIz0MVqdFibgK5meWHW0A22LMoJu55QgRnicicfRicGSxMpMoCGOXK8GUonGASHg1e4cqPXVsTzwkdLY8QDeLfNg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/08/17/1336_ex1.jpeg">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/08/17/1336_ex2.jpeg">
<meta property="og:image" content="https://pic.leetcode-cn.com/367df5172fd16d2637e591f6586d146772758438c66660c86719ffb2d36eb14d-image.png">
<meta property="og:image" content="c:%5CUsers%5CSean%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200424154203050.png">
<meta property="og:image" content="c:%5CUsers%5CSean%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200425214010242.png">
<meta property="og:image" content="c:%5CUsers%5CSean%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200424190820440.png">
<meta property="og:image" content="c:%5CUsers%5CSean%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200424190833421.png">
<meta property="og:image" content="c:%5CUsers%5CSean%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200425134116788.png">
<meta property="og:image" content="c:%5CUsers%5CSean%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200425134122971.png">
<meta property="og:image" content="c:%5CUsers%5CSean%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200425175655871.png">
<meta property="og:image" content="https://mmbiz.qlogo.cn/mmbiz_gif/D67peceibeISVzyopJgc0ZTiaCm5xWvaRfqzgkqo7WJcHziaic3yiaxjiaziaExuEfeuVvryxMRk9FQe16IERTDVcpvyw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1&retryload=2">
<meta property="og:image" content="c:%5CUsers%5CSean%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200425154614401.png">
<meta property="og:image" content="c:%5CUsers%5CSean%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200426182509526.png">
<meta property="og:image" content="c:%5CUsers%5CSean%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200423220008156.png">
<meta property="og:image" content="c:%5CUsers%5CSean%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200424154203050.png">
<meta property="og:image" content="c:/Users/Sean/AppData/Roaming/Typora/typora-user-images/image-20200425175838468.png">
<meta property="og:image" content="c:%5CUsers%5CSean%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200426100011470.png">
<meta property="og:image" content="c:%5CUsers%5CSean%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200426182509526.png">
<meta property="og:image" content="c:%5CUsers%5CSean%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200427094724254.png">
<meta property="og:image" content="c:%5CUsers%5CSean%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200427094724254.png">
<meta property="og:image" content="http://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png">
<meta property="og:image" content="http://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png">
<meta property="article:published_time" content="2020-07-18T06:58:32.000Z">
<meta property="article:modified_time" content="2020-07-18T10:39:52.916Z">
<meta property="article:author" content="J Len">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibkIz0MVqdFibgK5meWHW0A22LMoJu55Q2BIsAtY2cAicGnvmMeyjibqpum44XLBlf5iaCwIIQwkacib4nSklBdyDhQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://j-len.github.io/2020/07/18/BFS+DFS+回溯/"/>





  <title>BFS+DFS | J Len</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">J Len</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://j-len.github.io/2020/07/18/BFS+DFS+%E5%9B%9E%E6%BA%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="J Len">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J Len">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">BFS+DFS</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-18T14:58:32+08:00">
                2020-07-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/LeetCode/" itemprop="url" rel="index">
                    <span itemprop="name">LeetCode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="1-BFS（宽度优先搜索）"><a href="#1-BFS（宽度优先搜索）" class="headerlink" title="1  BFS（宽度优先搜索）"></a>1  BFS（宽度优先搜索）</h1><p>BFS 的核心思想应该不难理解的，就是把一些问题抽象成图，从一个点开始，向四周开始扩散。一般来说，我们写 BFS 算法都是用「队列」这种数据结构，每次将一个节点周围的所有节点加入队列。</p>
<p>BFS 相对 DFS 的最主要的区别是：<strong>BFS 找到的路径一定是最短的，但代价就是空间复杂度比 DFS 大很多</strong>，至于为什么，我们后面介绍了框架就很容易看出来了。</p>
<p>本文就由浅入深写两道 BFS 的典型题目，分别是「二叉树的最小高度」和「打开密码锁的最少步数」，手把手教你怎么写 BFS 算法。</p>
<h2 id="1-1-算法框架"><a href="#1-1-算法框架" class="headerlink" title="1.1 算法框架"></a>1.1 算法框架</h2><p>要说框架的话，我们先举例一下 BFS 出现的常见场景好吧，<strong>问题的本质就是让你在一幅「图」中找到从起点<code>start</code>到终点<code>target</code>的最近距离，这个例子听起来很枯燥，但是 BFS 算法问题其实都是在干这个事儿。</strong></p>
<p>把枯燥的本质搞清楚了，再去欣赏各种问题的包装才能胸有成竹嘛。</p>
<p>这个广义的描述可以有<strong>各种变体</strong>，比如<strong><em>走迷宫</em></strong>，有的格子是围墙不能走，从起点到终点的最短距离是多少？如果这个迷宫带「传送门」可以瞬间传送呢？</p>
<p>再比如说<strong><em>两个单词，要求你通过某些替换，把其中一个变成另一个</em></strong>，每次只能替换一个字符，最少要替换几次？</p>
<p>再比如说连连看游戏，两个方块消除的条件不仅仅是图案相同，还得保证两个方块之间的最短连线不能多于两个拐点。你玩连连看，点击两个坐标，游戏是如何判断它俩的最短连线有几个拐点的？</p>
<p>再比如……</p>
<p>净整些花里胡哨的，这些问题都没啥奇技淫巧，<strong>本质上就是一幅「图」，让你从一个起点，走到终点，问最短路径</strong>。这就是 BFS 的本质，框架搞清楚了直接默写就好。</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibkIz0MVqdFibgK5meWHW0A22LMoJu55Q2BIsAtY2cAicGnvmMeyjibqpum44XLBlf5iaCwIIQwkacib4nSklBdyDhQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>记住下面这个框架就 OK 了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算从起点 start 到终点 target 的最近距离</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(Node start, Node target)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Node&gt; q; <span class="comment">// 核心数据结构</span></span><br><span class="line">    Set&lt;Node&gt; visited; <span class="comment">// 避免走回头路</span></span><br><span class="line"></span><br><span class="line">    q.offer(start); <span class="comment">// 将起点加入队列</span></span><br><span class="line">    visited.add(start);</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>; <span class="comment">// 记录扩散的步数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q not empty) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="comment">/* 将当前队列中的所有节点向四周扩散 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            Node cur = q.poll();</span><br><span class="line">            <span class="comment">/* 划重点：这里判断是否到达终点 */</span></span><br><span class="line">            <span class="keyword">if</span> (cur is target)</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            <span class="comment">/* 将 cur 的相邻节点加入队列 */</span></span><br><span class="line">            <span class="keyword">for</span> (Node x : cur.adj())</span><br><span class="line">                <span class="comment">// 如果结点x没被访问过，则加入队列</span></span><br><span class="line">                <span class="keyword">if</span> (x not in visited) &#123;</span><br><span class="line">                    q.offer(x);</span><br><span class="line">                    visited.add(x);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 划重点：更新步数在这里 */</span></span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>队列<code>q</code>就不说了，BFS 的核心数据结构；<code>cur.adj()</code>泛指<code>cur</code>相邻的节点，比如说二维数组中，<code>cur</code>上下左右四面的位置就是相邻节点；<code>visited</code>的主要作用是防止走回头路，大部分时候都是必须的，但是像一般的二叉树结构，没有子节点到父节点的指针，不会走回头路就不需要<code>visited</code>。</p>
<h2 id="1-2-二叉树的最小高度-Leetcode-111"><a href="#1-2-二叉树的最小高度-Leetcode-111" class="headerlink" title="1.2 二叉树的最小高度  Leetcode-111"></a>1.2 二叉树的最小高度  Leetcode-111</h2><p>先来个简单的问题实践一下 BFS 框架吧，判断一棵二叉树的<strong>最小</strong>高度，这也是 LeetCode 第 111 题，看一下题目：</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibkIz0MVqdFibgK5meWHW0A22LMoJu55QH3cqLJFwFg4TIiaRpiasaDknlQDhMBLaxWJKsUzejz4514iciaicTPlHXDQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>怎么套到 BFS 的框架里呢？首先明确一下起点<code>start</code>和终点<code>target</code>是什么，怎么判断到达了终点？</p>
<p><strong>显然起点就是<code>root</code>根节点，终点就是最靠近根节点的那个「叶子节点」嘛</strong>，叶子节点就是两个子节点都是<code>null</code>的节点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur.left == null &amp;&amp; cur.right == null) </span><br><span class="line">    <span class="comment">// 到达叶子节点</span></span><br></pre></td></tr></table></figure>

<p>那么，按照我们上述的框架稍加改造来写解法即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line">    <span class="comment">// root 本身就是一层，depth 初始化为 1</span></span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="comment">/* 将当前队列中的所有节点向四周扩散 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            TreeNode cur = q.poll();</span><br><span class="line">            <span class="comment">/* 判断是否到达终点 */</span></span><br><span class="line">            <span class="keyword">if</span> (cur.left == <span class="keyword">null</span> &amp;&amp; cur.right == <span class="keyword">null</span>) </span><br><span class="line">                <span class="keyword">return</span> depth;</span><br><span class="line">            <span class="comment">/* 将 cur 的相邻节点加入队列 */</span></span><br><span class="line">            <span class="comment">/* 这里不同于一般的BFS框架，二叉树无法向前走，</span></span><br><span class="line"><span class="comment">            	所以不会出现访问已被访问过的点</span></span><br><span class="line"><span class="comment">            	也就不用判断是否被访问过</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>)</span><br><span class="line">                q.offer(cur.left);</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) </span><br><span class="line">                q.offer(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 这里增加步数 */</span></span><br><span class="line">        depth++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二叉树是很简单的数据结构，我想上述代码你应该可以理解的吧，其实其他复杂问题都是这个框架的变形，在探讨复杂问题之前，我们解答两个问题：</p>
<h3 id="Q1-为什么-BFS-可以找到最短距离，DFS-不行吗？"><a href="#Q1-为什么-BFS-可以找到最短距离，DFS-不行吗？" class="headerlink" title="Q1 为什么 BFS 可以找到最短距离，DFS 不行吗？"></a><strong>Q1 为什么 BFS 可以找到最短距离，DFS 不行吗</strong>？</h3><p>首先，你看 BFS 的逻辑，<code>depth</code>每增加一次，队列中的所有节点都向前迈一步，这保证了第一次到达终点的时候，走的步数是最少的。</p>
<p>DFS 不能找最短路径吗？其实也是可以的，但是时间复杂度相对高很多。</p>
<p>你想啊，DFS 实际上是靠递归的堆栈记录走过的路径，你要找到最短路径，肯定得把二叉树中所有树杈都探索完才能对比出最短的路径有多长对不对？</p>
<p>而 BFS 借助队列做到一次一步「齐头并进」，是可以在不遍历完整棵树的条件下找到最短距离的。</p>
<p>形象点说，DFS 是线，BFS 是面；DFS 是单打独斗，BFS 是集体行动。这个应该比较容易理解吧。</p>
<h3 id="Q2-既然-BFS-那么好，为啥-DFS-还要存在？"><a href="#Q2-既然-BFS-那么好，为啥-DFS-还要存在？" class="headerlink" title="Q2 既然 BFS 那么好，为啥 DFS 还要存在？"></a><strong>Q2 既然 BFS 那么好，为啥 DFS 还要存在</strong>？</h3><blockquote>
<p><em>BFS 可以找到最短距离，但是空间复杂度高，而 DFS 的空间复杂度较低**。</em></p>
</blockquote>
<p>还是拿刚才我们处理二叉树问题的例子，假设给你的这个二叉树是满二叉树，节点总数为<code>N</code>，对于 DFS 算法来说，空间复杂度无非就是递归堆栈，最坏情况下顶多就是树的高度，也就是<code>O(logN)</code>。</p>
<p>但是你想想 BFS 算法，队列中每次都会储存着二叉树一层的节点，这样的话最坏情况下空间复杂度应该是树的最底层节点的数量，也就是<code>N/2</code>，用 Big O 表示的话也就是<code>O(N)</code>。</p>
<p>由此观之，BFS 还是有代价的，<strong>一般来说在找最短路径的时候使用 BFS，其他时候还是 DFS 使用得多一些</strong>（主要是递归代码好写）。</p>
<p>好了，现在你对 BFS 了解得足够多了，下面来一道难一点的题目，深化一下框架的理解吧。</p>
<h2 id="1-3-解开密码锁的最少次数-Leetcode-752"><a href="#1-3-解开密码锁的最少次数-Leetcode-752" class="headerlink" title="1.3 解开密码锁的最少次数  Leetcode-752"></a>1.3 解开密码锁的最少次数  Leetcode-752</h2><p>这道 LeetCode 题目是第 752 题，比较有意思：</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibkIz0MVqdFibgK5meWHW0A22LMoJu55QnaxXtUnzc3YWR3PpicMwtL2DWEAI7H6lXOQaRqNYJK3Iw4EMs8DkFGg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>题目中描述的就是我们生活中常见的那种密码锁，若果没有任何约束，最少的拨动次数很好算，就像我们平时开密码锁那样直奔密码拨就行了。</p>
<p>但现在的难点就在于，不能出现<code>deadends</code>，应该如何计算出最少的转动次数呢？</p>
<p><strong>第一步，我们不管所有的限制条件，不管<code>deadends</code>和<code>target</code>的限制，就思考一个问题：如果让你设计一个算法，穷举所有可能的密码组合，你怎么做</strong>？</p>
<p>穷举呗，再简单一点，如果你只转一下锁，有几种可能？总共有 4 个位置，每个位置可以向上转，也可以向下转，也就是有 8 种可能对吧。</p>
<p>比如说从<code>&quot;0000&quot;</code>开始，转一次，可以穷举出<code>&quot;1000&quot;, &quot;9000&quot;, &quot;0100&quot;, &quot;0900&quot;...</code>共 8 种密码。然后，再以这 8 种密码作为基础，对每个密码再转一下，穷举出所有可能…</p>
<p><strong>仔细想想，这就可以抽象成一幅图，每个节点有 8 个相邻的节点</strong>，又让你求最短距离，这不就是典型的 BFS 嘛，框架就可以派上用场了，先写出一个「简陋」的 BFS 框架代码再说别的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 s[j] 向上拨动一次</span></span><br><span class="line"><span class="function">String <span class="title">plusOne</span><span class="params">(String s, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] ch = s.toCharArray();</span><br><span class="line">    <span class="keyword">if</span> (ch[j] == <span class="string">'9'</span>)</span><br><span class="line">        ch[j] = <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ch[j] += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(ch);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 s[i] 向下拨动一次</span></span><br><span class="line"><span class="function">String <span class="title">minusOne</span><span class="params">(String s, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] ch = s.toCharArray();</span><br><span class="line">    <span class="keyword">if</span> (ch[j] == <span class="string">'0'</span>)</span><br><span class="line">        ch[j] = <span class="string">'9'</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ch[j] -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BFS 框架，打印出所有可能的密码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(String target)</span> </span>&#123;</span><br><span class="line">    Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.offer(<span class="string">"0000"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="comment">/* 将当前队列中的所有节点向周围扩散 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            String cur = q.poll();</span><br><span class="line">            <span class="comment">/* 判断是否到达终点 */</span></span><br><span class="line">            System.out.println(cur);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 将一个节点的相邻节点加入队列 */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                String up = plusOne(cur, j);</span><br><span class="line">                String down = minusOne(cur, j);</span><br><span class="line">                q.offer(up);</span><br><span class="line">                q.offer(down);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 在这里增加步数 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PS：这段代码当然有很多问题，但是我们做算法题肯定不是一蹴而就的，而是从简陋到完美的。不要完美主义，咱要慢慢来，好不。</p>
<p><strong>这段 BFS 代码已经能够穷举所有可能的密码组合了，但是显然不能完成题目，有如下问题需要解决</strong>：</p>
<p>1、会走回头路。比如说我们从<code>&quot;0000&quot;</code>拨到<code>&quot;1000&quot;</code>，但是等从队列拿出<code>&quot;1000&quot;</code>时，还会拨出一个<code>&quot;0000&quot;</code>，这样的话会产生死循环。</p>
<p>2、没有终止条件，按照题目要求，我们找到<code>target</code>就应该结束并返回拨动的次数。</p>
<p>3、没有对<code>deadends</code>的处理，按道理这些「死亡密码」是不能出现的，也就是说你遇到这些密码的时候需要跳过。</p>
<p>如果你能够看懂上面那段代码，真得给你鼓掌，只要按照 BFS 框架在对应的位置稍作修改即可修复这些问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openLock</span><span class="params">(String[] deadends, String target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录需要跳过的死亡密码</span></span><br><span class="line">    Set&lt;String&gt; deads = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String s : deadends) deads.add(s);</span><br><span class="line">    <span class="comment">// 记录已经穷举过的密码，防止走回头路</span></span><br><span class="line">    Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 从起点开始启动广度优先搜索</span></span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    q.offer(<span class="string">"0000"</span>);</span><br><span class="line">    visited.add(<span class="string">"0000"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="comment">/* 将当前队列中的所有节点向周围扩散 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            String cur = q.poll();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 判断是否到达终点 */</span></span><br><span class="line">            <span class="keyword">if</span> (deads.contains(cur))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur.equals(target))</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 将一个节点的未遍历相邻节点加入队列 */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                String up = plusOne(cur, j);</span><br><span class="line">                <span class="keyword">if</span> (!visited.contains(up)) &#123;</span><br><span class="line">                    q.offer(up);</span><br><span class="line">                    visited.add(up);</span><br><span class="line">                &#125;</span><br><span class="line">                String down = minusOne(cur, j);</span><br><span class="line">                <span class="keyword">if</span> (!visited.contains(down)) &#123;</span><br><span class="line">                    q.offer(down);</span><br><span class="line">                    visited.add(down);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 在这里增加步数 */</span></span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果穷举完都没找到目标密码，那就是找不到了</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们就解决这道题目了。有一个比较小的优化：可以不需要<code>dead</code>这个哈希集合，可以直接将这些元素初始化到<code>visited</code>集合中，效果是一样的，可能更加优雅一些。</p>
<h2 id="1-4-机器人的运动范围-面试题-13"><a href="#1-4-机器人的运动范围-面试题-13" class="headerlink" title="1.4 机器人的运动范围  面试题-13"></a>1.4 机器人的运动范围  面试题-13</h2><p><img src="C:%5CUsers%5CSean%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200423220008156.png" alt="image-20200423220008156"></p>
<p>作者：fuxuemingzhu<br>链接：<a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/solution/bfsmo-ban-yi-ci-bei-hui-chu-chu-shi-yong-by-fuxuem/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/solution/bfsmo-ban-yi-ci-bei-hui-chu-chu-shi-yong-by-fuxuem/</a></p>
<p><strong>思路：</strong></p>
<p>本题要求总的有多少个点符合要求，<strong>本质是个搜索问题</strong>。搜索问题可以用 BFS 或者 DFS，都有相应的模板。</p>
<p>我在博客中已经总结了所有常见的算法模板，<a href="https://blog.csdn.net/fuxuemingzhu/article/details/101900729" target="_blank" rel="noopener">【LeetCode】代码模板，刷题必会</a>，刷题必会，直接拿来用！</p>
<p>BFS使用队列，把每个还没有搜索到的点一次放入队列，然后再弹出队列的头部元素当做当前遍历点。</p>
<p><strong>如果不需要确定当前遍历到了哪一层</strong>，BFS模板如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> queue 不空：</span><br><span class="line">    cur = queue.pop()</span><br><span class="line">    <span class="keyword">for</span> 节点 in cur的所有相邻节点：</span><br><span class="line">        <span class="keyword">if</span> 该节点有效且未访问过：</span><br><span class="line">            queue.push(该节点)</span><br></pre></td></tr></table></figure>

<p><strong>如果要确定当前遍历到了哪一层</strong>（<strong>最短路径问题</strong>），BFS模板如下。</p>
<p>这里增加了level表示当前遍历到二叉树中的哪一层了，也可以理解为在一个图中，现在已经走了多少步了。size表示在开始遍历新的一层时，队列中有多少个元素，即有多少个点需要向前走一步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">level = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> queue 不空：</span><br><span class="line">    size = queue.size()</span><br><span class="line">    <span class="comment">// size表示在开始遍历新的一层时，队列中有多少个元素</span></span><br><span class="line">    <span class="keyword">while</span> (size --) &#123;</span><br><span class="line">        cur = queue.pop()</span><br><span class="line">        <span class="keyword">for</span> 节点 in cur的所有相邻节点：</span><br><span class="line">            <span class="keyword">if</span> 该节点有效且未被访问过：</span><br><span class="line">                queue.push(该节点)</span><br><span class="line">    &#125;</span><br><span class="line">    level ++;</span><br></pre></td></tr></table></figure>


<p>上面两个是通用模板，在任何题目中都可以用，是要记住的！</p>
<p><strong>本题不需要记录遍历到多少层，只需要统计总的遍历了多少个点，因此使用模板一</strong>。</p>
<p><strong>保存一个点是否遍历过：使用了visited数组，如果一个点放入队列，那么同时就设置其已经visited了</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        q.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        visited[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// res初始化为1</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dx = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dy = &#123;<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span>[] pos = q.poll();</span><br><span class="line">            <span class="keyword">int</span> x = pos[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = pos[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> newX = x + dx[i];</span><br><span class="line">                <span class="keyword">int</span> newY = y + dy[i];</span><br><span class="line">                <span class="keyword">if</span>(newX&lt;<span class="number">0</span> || newX&gt;=m || newY&lt;<span class="number">0</span> || newY&gt;=n || visited[newX][newY] || getDigitSum(newX,newY)&gt;k)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                q.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;newX,newY&#125;);</span><br><span class="line">                visited[newX][newY] = <span class="keyword">true</span>;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDigitSum</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            sum += i%<span class="number">10</span>;</span><br><span class="line">            i /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            sum += j%<span class="number">10</span>;</span><br><span class="line">            j /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-5-双向BFS优化"><a href="#1-5-双向BFS优化" class="headerlink" title="1.5 双向BFS优化"></a>1.5 双向BFS优化</h2><p>你以为到这里 BFS 算法就结束了？恰恰相反。BFS 算法还有一种稍微高级一点的优化思路：<strong>双向 BFS</strong>，可以进一步提高算法的效率。</p>
<p>篇幅所限，这里就提一下区别：<strong>传统的 BFS 框架就是从起点开始向四周扩散，遇到终点时停止；而双向 BFS 则是从起点和终点同时开始扩散，当两边有交集的时候停止</strong>。</p>
<p>为什么这样能够能够提升效率呢？其实从 Big O 表示法分析算法复杂度的话，它俩的最坏复杂度都是<code>O(N)</code>，但是实际上双向 BFS 确实会快一些，我给你画两张图看一眼就明白了：</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibkIz0MVqdFibgK5meWHW0A22LMoJu55QJg6mpZUWAk3oyibLDgNiaJAC8icl3TIgd6kHGd6ymr0OmACWguIoS6ibYA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibkIz0MVqdFibgK5meWHW0A22LMoJu55QgRnicicfRicGSxMpMoCGOXK8GUonGASHg1e4cqPXVsTzwkdLY8QDeLfNg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>图示中的树形结构，如果终点在最底部，按照传统 BFS 算法的策略，会把整棵树的节点都搜索一遍，最后找到<code>target</code>；而双向 BFS 其实只遍历了半棵树就出现了交集，也就是找到了最短距离。从这个例子可以直观地感受到，双向 BFS 是要比传统 BFS 高效的。</p>
<p><strong>不过，双向 BFS 也有局限，因为你必须知道终点在哪里</strong>。比如我们刚才讨论的二叉树最小高度的问题，你一开始根本就不知道终点在哪里，也就无法使用双向 BFS；但是第二个密码锁的问题，是可以使用双向 BFS 算法来提高效率的，代码稍加修改即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openLock</span><span class="params">(<span class="keyword">String</span>[] deadends, <span class="keyword">String</span> target)</span> </span>&#123;</span><br><span class="line">    Set&lt;<span class="keyword">String</span>&gt; deads = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">String</span> s : deadends) deads.add(s);</span><br><span class="line">    <span class="comment">// 用集合不用队列，可以快速判断元素是否存在</span></span><br><span class="line">    Set&lt;<span class="keyword">String</span>&gt; q1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;<span class="keyword">String</span>&gt; q2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;<span class="keyword">String</span>&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">step</span> = <span class="number">0</span>;</span><br><span class="line">    q1.add(<span class="string">"0000"</span>);</span><br><span class="line">    q2.add(target);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q1.isEmpty() &amp;&amp; !q2.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 哈希集合在遍历的过程中不能修改，用 temp 存储扩散结果</span></span><br><span class="line">        Set&lt;<span class="keyword">String</span>&gt; temp = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 将 q1 中的所有节点向周围扩散 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">String</span> cur : q1) &#123;</span><br><span class="line">            <span class="comment">/* 判断是否到达终点 */</span></span><br><span class="line">            <span class="keyword">if</span> (deads.contains(cur))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (q2.contains(cur))</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">step</span>;</span><br><span class="line">            visited.add(cur);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 将一个节点的未遍历相邻节点加入集合 */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">String</span> up = plusOne(cur, j);</span><br><span class="line">                <span class="keyword">if</span> (!visited.contains(up))</span><br><span class="line">                    temp.add(up);</span><br><span class="line">                <span class="keyword">String</span> down = minusOne(cur, j);</span><br><span class="line">                <span class="keyword">if</span> (!visited.contains(down))</span><br><span class="line">                    temp.add(down);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 在这里增加步数 */</span></span><br><span class="line">        <span class="built_in">step</span>++;</span><br><span class="line">        <span class="comment">// temp 相当于 q1</span></span><br><span class="line">        <span class="comment">// 这里交换 q1 q2，下一轮 while 就是扩散 q2</span></span><br><span class="line">        q1 = q2;</span><br><span class="line">        q2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双向 BFS 还是遵循 BFS 算法框架的，只是<strong>不再使用队列，而是使用 HashSet 方便快速判断两个集合是否有交集</strong>。</p>
<p>另外的一个技巧点就是 <strong>while 循环的最后交换<code>q1</code>和<code>q2</code>的内容</strong>，所以只要默认扩散<code>q1</code>就相当于轮流扩散<code>q1</code>和<code>q2</code>。</p>
<p>其实双向 BFS 还有一个优化，就是在 while 循环开始时做一个判断：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">while</span> (!q1.isEmpty() &amp;&amp; !q2.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (q1.<span class="built_in">size</span>() &gt; q2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="comment">// 交换 q1 和 q2</span></span><br><span class="line">        temp = q1;</span><br><span class="line">        q1 = q2;</span><br><span class="line">        q2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>为什么这是一个优化呢？</p>
<p>因为按照 BFS 的逻辑，队列（集合）中的元素越多，扩散之后新的队列（集合）中的元素就越多；在双向 BFS 算法中，如果我们每次都选择一个较小的集合进行扩散，那么占用的空间增长速度就会慢一些，效率就会高一些。</p>
<p>不过话说回来，<strong>无论传统 BFS 还是双向 BFS，无论做不做优化，从 Big O 衡量标准来看，空间复杂度都是一样的</strong>，只能说双向 BFS 是一种 trick 吧，掌握不掌握其实都无所谓。最关键的是把 BFS 通用框架记下来，反正所有 BFS 算法都可以用它套出解法。</p>
<h2 id="1-6-图的多源BFS"><a href="#1-6-图的多源BFS" class="headerlink" title="1.6 图的多源BFS"></a>1.6 图的多源BFS</h2><h3 id="1-6-1-地图分析-Leetcode-1162"><a href="#1-6-1-地图分析-Leetcode-1162" class="headerlink" title="1.6.1 地图分析  Leetcode-1162"></a>1.6.1 地图分析  Leetcode-1162</h3><p>你现在手里有一份大小为 N x N 的「地图」（网格） <code>grid</code>，上面的每个「区域」（单元格）都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地，请你找出一个海洋区域，这个海洋区域到离它最近的陆地区域的距离是最大的。</p>
<p>我们这里说的距离是「曼哈顿距离」（ Manhattan Distance）：(x0, y0) 和 (x1, y1) 这两个区域之间的距离是 |x0 - x1| + |y0 - y1| 。</p>
<p>如果我们的地图上只有陆地或者海洋，请返回 -1。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/08/17/1336_ex1.jpeg" alt="img"></p>
<blockquote>
<p><strong>输入</strong>：[[1,0,1],[0,0,0],[1,0,1]]<br><strong>输出</strong>：2<br><strong>解释</strong>：<br>海洋区域 (1, 1) 和所有陆地区域之间的距离都达到最大，最大距离为 2。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/08/17/1336_ex2.jpeg" alt="img"></p>
<blockquote>
<p><strong>输入</strong>：[[1,0,0],[0,0,0],[0,0,0]]<br><strong>输出</strong>：4<br><strong>解释</strong>：<br>海洋区域 (2, 2) 和所有陆地区域之间的距离都达到最大，最大距离为 4。</p>
</blockquote>
<p><strong>提示：</strong></p>
<blockquote>
<p>1 &lt;= grid.length == grid[0].length &lt;= 100<br>grid[i][j]不是0就是1</p>
</blockquote>
<p><strong>一、题目分析</strong></p>
<p>作者：sweetiee<br>链接：<a href="https://leetcode-cn.com/problems/as-far-from-land-as-possible/solution/jian-dan-java-miao-dong-tu-de-bfs-by-sweetiee/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/as-far-from-land-as-possible/solution/jian-dan-java-miao-dong-tu-de-bfs-by-sweetiee/</a></p>
<p>相信对于<strong>Tree的BFS</strong>大家都已经轻车熟路了：要把root节点先入队，然后再一层一层的无脑遍历就行了。</p>
<p>对于<strong>图的BFS</strong>也是一样滴～ 与Tree的BFS区别如下：<br><strong>1、tree只有1个root，而图可以有多个源点，所以首先需要把多个源点都入队。</strong><br><strong>2、tree是有向的因此不需要标志是否访问过，而对于无向图来说，必须得标志是否访问过！</strong><br><strong>并且为了防止某个节点多次入队，需要在入队之前就将其设置成已访问！</strong></p>
<p><strong>这是一道典型的BFS基础应用，为什么这么说呢？</strong><br>因为我们只要先把所有的陆地都入队，然后从各个陆地同时开始一层一层的向海洋扩散，那么最后扩散到的海洋就是最远的海洋！<br>并且这个海洋肯定是被离他最近的陆地给扩散到的！<br>下面是扩散的图示，1表示陆地，0表示海洋。每次扩散的时候会标记相邻的4个位置的海洋：</p>
<p><img src="https://pic.leetcode-cn.com/367df5172fd16d2637e591f6586d146772758438c66660c86719ffb2d36eb14d-image.png" alt="image.png"></p>
<p>你可以想象成你从每个陆地上派了很多支船去踏上伟大航道，踏遍所有的海洋。每当船到了新的海洋，就会分裂成4条新的船，向新的未知海洋前进（访问过的海洋就不去了）。如果船到达了某个未访问过的海洋，那他们是第一个到这片海洋的。很明显，这么多船最后访问到的海洋，肯定是离陆地最远的海洋。</p>
<p><strong>二、代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dx = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dy = &#123;<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 先把所有的陆地都入队。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从各个陆地开始，一圈一圈的遍历海洋，最后遍历到的海洋就是离陆地最远的海洋。</span></span><br><span class="line">        <span class="keyword">boolean</span> hasOcean = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span>[] point = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            point = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> x = point[<span class="number">0</span>], y = point[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 取出队列的元素，将其四周的海洋入队。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> newX = x + dx[i];</span><br><span class="line">                <span class="keyword">int</span> newY = y + dy[i];</span><br><span class="line">                <span class="keyword">if</span> (newX &lt; <span class="number">0</span> || newX &gt;= m || newY &lt; <span class="number">0</span> || newY &gt;= n || grid[newX][newY] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                grid[newX][newY] = grid[x][y] + <span class="number">1</span>; <span class="comment">// 这里我直接修改了原数组，因此就不需要额外的数组来标志是否访问</span></span><br><span class="line">                hasOcean = <span class="keyword">true</span>;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;newX, newY&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有陆地或者没有海洋，返回-1。</span></span><br><span class="line">        <span class="keyword">if</span> (point == <span class="keyword">null</span> || !hasOcean) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回最后一次遍历到的海洋的距离。</span></span><br><span class="line">        <span class="keyword">return</span> grid[point[<span class="number">0</span>]][point[<span class="number">1</span>]] - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-6-2-岛屿的最大面积-Leetcode-695"><a href="#1-6-2-岛屿的最大面积-Leetcode-695" class="headerlink" title="1.6.2 岛屿的最大面积  Leetcode-695"></a>1.6.2 岛屿的最大面积  Leetcode-695</h3><p><strong>题目同2.2</strong></p>
<p><img src="C:%5CUsers%5CSean%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200424154203050.png" alt="image-20200424154203050"></p>
<p><strong>广度优先遍历（队列实现）</strong></p>
<p>作者：wang_dong<br>链接：<a href="https://leetcode-cn.com/problems/max-area-of-island/solution/javaban-3chong-jie-fa-by-wang_dong/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/max-area-of-island/solution/javaban-3chong-jie-fa-by-wang_dong/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		<span class="keyword">int</span> rows = grid.length;</span><br><span class="line">        <span class="keyword">int</span> columns = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[] dx = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dy = &#123;<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; j++) &#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">                <span class="keyword">int</span> currArea = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">int</span> size = queue.size();</span><br><span class="line">                    <span class="keyword">while</span> (size--&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span>[] curr = queue.poll();</span><br><span class="line">                        <span class="keyword">int</span> currX = curr[<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">int</span> currY = curr[<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span> (currX &lt; <span class="number">0</span> || currX &gt;= rows || currY &lt; <span class="number">0</span> || currY &gt;= columns || grid[currX][currY] == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 找到一块相邻陆地，面积加1，并标记为访问过</span></span><br><span class="line">                        currArea++;</span><br><span class="line">                        grid[currX][currY] = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">4</span>; k++) &#123;</span><br><span class="line">                            <span class="keyword">int</span> newX = currX + dx[k];</span><br><span class="line">                            <span class="keyword">int</span> newY = currY + dy[k];</span><br><span class="line">                            queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;newX,newY&#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                maxArea = Math.max(maxArea, currArea);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-6-3-被围绕的区域-Leetcode-130"><a href="#1-6-3-被围绕的区域-Leetcode-130" class="headerlink" title="1.6.3 被围绕的区域  Leetcode-130"></a>1.6.3 被围绕的区域  Leetcode-130</h3><p><img src="C:%5CUsers%5CSean%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200425214010242.png" alt="image-20200425214010242"></p>
<p><strong>本题同<code>1.6.2</code></strong></p>
<p><strong>思路</strong></p>
<p>这道题我们拿到基本就可以确定是图的 dfs、bfs 遍历的题目了。题目中解释说被包围的区间不会存在于边界上，所以我们会想到<strong>边界上的 <code>O</code>要特殊处理，只要把边界上的 <code>O</code> 特殊处理了</strong>，那么剩下的 <code>O</code>替换成 <code>X</code> 就可以了。问题转化为，如何寻找和边界联通的 <code>O</code>，我们需要考虑如下情况。</p>
<p>X  X X  X<br>X O O X<br>X X O X<br>X O O X<br>这时候的 <code>O</code>是不做替换的。因为和边界是连通的。为了记录这种状态，我们把这种情况下的 <code>O</code> 换成 <code>#</code> 作为占位符，待搜索结束之后，遇到 <code>O</code>替换为 <code>X</code>（和边界不连通的 <code>O</code>）；遇到 <code>#</code>，替换回 <code>O</code>(和边界连通的 <code>O</code>)。</p>
<blockquote>
<p>作者：Ac_pipe<br>链接：<a href="https://leetcode-cn.com/problems/surrounded-regions/solution/bfsdi-gui-dfsfei-di-gui-dfsbing-cha-ji-by-ac_pipe/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/surrounded-regions/solution/bfsdi-gui-dfsfei-di-gui-dfsbing-cha-ji-by-ac_pipe/</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> rows = board.length;</span><br><span class="line">        <span class="keyword">if</span>(rows==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> columns = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[] dx = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dy = &#123;<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][columns];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;rows; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;columns; j++)&#123;</span><br><span class="line">                <span class="comment">// 从边界扩展这个思路太棒了，相当于把问题转化为1.6.2最大岛屿面积问题</span></span><br><span class="line">                <span class="keyword">if</span>((i==<span class="number">0</span> || i==rows-<span class="number">1</span> || j==<span class="number">0</span> || j==columns-<span class="number">1</span>) &amp;&amp; board[i][j]==<span class="string">'O'</span> &amp;&amp; !visited[i][j])&#123;</span><br><span class="line">                    q.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);</span><br><span class="line">                    visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">                        <span class="comment">//int size = q.size();</span></span><br><span class="line">                        <span class="comment">// 这里不需要再按BFS的模板套用while(size--&gt;0)</span></span><br><span class="line">                        <span class="comment">// 因为不死要求最短路径</span></span><br><span class="line">                        <span class="comment">// 思路和最大岛屿面积相同</span></span><br><span class="line">                        <span class="keyword">int</span>[] curr = q.poll();</span><br><span class="line">                        <span class="keyword">int</span> currX = curr[<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">int</span> currY = curr[<span class="number">1</span>];</span><br><span class="line">                        <span class="comment">//board[currX][currY] = '*';</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">4</span>; k++)&#123;</span><br><span class="line">                            <span class="keyword">int</span> newX = currX + dx[k];</span><br><span class="line">                            <span class="keyword">int</span> newY = currY + dy[k];</span><br><span class="line">                            <span class="keyword">if</span>(newX&lt;<span class="number">0</span> || newX&gt;=rows || newY&lt;<span class="number">0</span> || newY&gt;=columns || board[newX][newY]==<span class="string">'X'</span> || visited[newX][newY])&#123;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            q.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;newX,newY&#125;);</span><br><span class="line">                            <span class="comment">// 一定要紧接着q.offer()后面标记该点已访问过</span></span><br><span class="line">                            <span class="comment">// 保证进入队列的都是已标记访问过的</span></span><br><span class="line">                            visited[newX][newY] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for(int i=0; i&lt;rows; i++)&#123;</span></span><br><span class="line">        <span class="comment">//     for(int j=0; j&lt;columns; j++)&#123;</span></span><br><span class="line">        <span class="comment">//         if(board[i][j] == 'O')&#123;</span></span><br><span class="line">        <span class="comment">//             board[i][j] = 'X';</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//         if(board[i][j] == '*')&#123;</span></span><br><span class="line">        <span class="comment">//             board[i][j] = 'O';</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;rows; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;columns; j++)&#123;</span><br><span class="line">                <span class="comment">// 标记为访问过的都是不需要变换的‘O’</span></span><br><span class="line">                <span class="keyword">if</span>(visited[i][j])&#123;</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-6-4-腐烂的橘子-Leetcode-994"><a href="#1-6-4-腐烂的橘子-Leetcode-994" class="headerlink" title="1.6.4 腐烂的橘子  Leetcode-994"></a>1.6.4 腐烂的橘子  Leetcode-994</h3><p><img src="C:%5CUsers%5CSean%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200424190820440.png" alt="image-20200424190820440"></p>
<p><img src="C:%5CUsers%5CSean%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200424190833421.png" alt="image-20200424190833421"></p>
<p><strong>思路：多源BFS</strong></p>
<p>类似1.5题，先将腐烂的橘子入队列，一层层的搜索附近的新鲜橘子，一旦有新鲜橘子就将其变为烂橘子并标记为访问过。队列为空时如果橘子数目&gt;0，则返回-1，否则返回步数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">orangesRotting</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> minutes = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> rows = grid.length;</span><br><span class="line">        <span class="keyword">int</span> columns = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[] dx = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dy = &#123;<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">// 定义新鲜橘子数目</span></span><br><span class="line">        <span class="keyword">int</span> freshOrange = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][columns];</span><br><span class="line">        <span class="comment">// 遍历二维数组，将烂橘子入队，同时统计烂橘子的个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;rows; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;columns; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">2</span>)&#123;</span><br><span class="line">                    q.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    freshOrange++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span>[] curr = q.poll();</span><br><span class="line">                <span class="keyword">int</span> currX = curr[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> currY = curr[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(currX&lt;<span class="number">0</span> || currX&gt;=rows || currY&lt;<span class="number">0</span> || currY&gt;=columns || grid[currX][currY] == <span class="number">0</span> || visited[currX][currY])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 新鲜橘子，将其变为烂橘子，同时新鲜橘子数目减一</span></span><br><span class="line">                <span class="keyword">if</span> (grid[currX][currY] == <span class="number">1</span>)&#123;</span><br><span class="line">                    grid[currX][currY] = <span class="number">2</span>;</span><br><span class="line">                    freshOrange--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 标记为访问过</span></span><br><span class="line">                visited[currX][currY] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 四个方向添加相邻橘子</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">4</span>; k++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> newX = currX + dx[k];</span><br><span class="line">                    <span class="keyword">int</span> newY = currY + dy[k];</span><br><span class="line">                    q.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;newX,newY&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 一旦出现“新鲜句子被消灭殆尽的情况，就返回答案，终止程序”</span></span><br><span class="line">            <span class="comment">// 避免后面不必要的搜索,从而满足题目说的“最少分钟数”的要求</span></span><br><span class="line">            minutes +=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (freshOrange==<span class="number">0</span>) <span class="keyword">return</span> minutes;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 坏橘子全部遍历完，别忘了再判断有没有</span></span><br><span class="line">        <span class="keyword">if</span>(freshOrange != <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> minutes==-<span class="number">1</span>?<span class="number">0</span>:minutes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-6-5-地图分析"><a href="#1-6-5-地图分析" class="headerlink" title="1.6.5 地图分析"></a>1.6.5 地图分析</h3><p><img src="C:%5CUsers%5CSean%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200425134116788.png" alt="image-20200425134116788"></p>
<p><img src="C:%5CUsers%5CSean%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200425134122971.png" alt="image-20200425134122971"></p>
<p><strong>解读题目中的「最远」和「最近」</strong></p>
<ul>
<li><p>题目问的是「距离陆地区域最远的海洋区域」，其实就是从陆地开始，要扩散多少次，才能把所有的海洋给覆盖掉。「最远」应该从这个角度来理解。</p>
</li>
<li><p>而「该海洋区域到离它最近的陆地区域的距离」，「最近」是因为一定是距离这个最后才扩散到的海洋的最近的陆地才能扩散到它。</p>
</li>
</ul>
<p><strong>分析：</strong></p>
<ul>
<li><p>二维表格上的问题，常用的算法是深度优先遍历、广度优先遍历和并查集，由于这里计算的结果和距离相关，显然使用广度优先遍历；</p>
</li>
<li><p>但是题目问的是「距离陆地区域最远的海洋区域」，这和我们的经验稍微有点出入。一般而言，「广度优先遍历」求的是最短路径，但仔细一想，发现其实广度优先遍历也是适用的：</p>
<ul>
<li>求最短路径的时候，只要找到目标值，返回即可；求最长路径的时候，所有目标值都看完以后，才返回。</li>
</ul>
</li>
<li><p>这道题「广度优先遍历」的起点有多个，但完全不影响算法的正确性，可以假想一个虚拟的起点，初始的起点就是由虚拟起点扩散开来的，示意图可以参考题解（<a href="https://leetcode-cn.com/problems/as-far-from-land-as-possible/solution/zhen-liang-yan-sou-huan-neng-duo-yuan-kan-wan-miao/）特别形象。" target="_blank" rel="noopener">https://leetcode-cn.com/problems/as-far-from-land-as-possible/solution/zhen-liang-yan-sou-huan-neng-duo-yuan-kan-wan-miao/）特别形象。</a></p>
</li>
<li><p>这里题目中介绍的「曼哈顿距离」，其实就是对广度优先遍历（BFS）逐层向外扩散的精准数学解释，每扩散一次，曼哈顿距离就加 1。</p>
</li>
</ul>
<p><strong>编写广度优先遍历算法的注意事项：</strong></p>
<ul>
<li>如果题目要求返回的结果和距离相关，需要在 while 循环内部一下子把当前列表的所有元素都依次取出来，这种「一下子」操作的次数就是我们需要的距离；</li>
<li>如果一个单元格被添加到队列以后，需要马上将它标记为已经访问（根据情况，可以直接在原始输入数组上修改，也可以使用一个布尔数组 visited 进行标记），如果不这么做，很可能会出现死循环，这一点如果一开始没有注意到，也可以通过调试代码观察出。</li>
</ul>
<p>作者：liweiwei1419<br>链接：<a href="https://leetcode-cn.com/problems/as-far-from-land-as-possible/solution/yan-du-you-xian-bian-li-java-by-liweiwei1419/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/as-far-from-land-as-possible/solution/yan-du-you-xian-bian-li-java-by-liweiwei1419/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dx = &#123;<span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dy = &#123;-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> rows = grid.length, columns = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][columns];</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> maxDistance = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> zeroNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;rows; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;columns; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    q.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    zeroNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(q.isEmpty() || q.size() == rows*columns) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span>[] curr = q.poll();</span><br><span class="line">                <span class="keyword">int</span> currX = curr[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> currY = curr[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(currX&lt;<span class="number">0</span> || currX&gt;=rows || currY&lt;<span class="number">0</span> || currY&gt;=columns || visited[currX][currY])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                visited[currX][currY] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(grid[currX][currY]==<span class="number">0</span>)&#123;</span><br><span class="line">                    zeroNum--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">4</span>; k++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> newX = currX + dx[k];</span><br><span class="line">                    <span class="keyword">int</span> newY = currY + dy[k];</span><br><span class="line">                    q.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;newX,newY&#125;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(zeroNum == <span class="number">0</span>) <span class="keyword">return</span> maxDistance;</span><br><span class="line">            maxDistance +=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxDistance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优化解法2：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dx = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dy = &#123;<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 先把所有的陆地都入队。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从各个陆地开始，一圈一圈的遍历海洋，最后遍历到的海洋就是离陆地最远的海洋。</span></span><br><span class="line">        <span class="keyword">boolean</span> hasOcean = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span>[] point = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            point = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> x = point[<span class="number">0</span>], y = point[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 取出队列的元素，将其四周的海洋入队。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> newX = x + dx[i];</span><br><span class="line">                <span class="keyword">int</span> newY = y + dy[i];</span><br><span class="line">                <span class="keyword">if</span> (newX &lt; <span class="number">0</span> || newX &gt;= m || newY &lt; <span class="number">0</span> || newY &gt;= n || grid[newX][newY] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                grid[newX][newY] = grid[x][y] + <span class="number">1</span>; <span class="comment">// 这里我直接修改了原数组，因此就不需要额外的数组来标志是否访问</span></span><br><span class="line">                hasOcean = <span class="keyword">true</span>;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;newX, newY&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有陆地或者没有海洋，返回-1。</span></span><br><span class="line">        <span class="keyword">if</span> (point == <span class="keyword">null</span> || !hasOcean) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回最后一次遍历到的海洋的距离。</span></span><br><span class="line">        <span class="keyword">return</span> grid[point[<span class="number">0</span>]][point[<span class="number">1</span>]] - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：sweetiee</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/as-far-from-land-as-possible/solution/jian-dan-java-miao-dong-tu-de-bfs-by-sweetiee/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>



<h3 id="1-6-6-岛屿数量-Leetcode-200"><a href="#1-6-6-岛屿数量-Leetcode-200" class="headerlink" title="1.6.6 岛屿数量  Leetcode-200"></a>1.6.6 岛屿数量  Leetcode-200</h3><p><img src="C:%5CUsers%5CSean%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200425175655871.png" alt="image-20200425175655871"></p>
<p><strong>类似题目<code>1.6.2</code></strong></p>
<p>遍历二维数组，遇到1的时候就将其加队列，然后开始BFS，每次将相邻位置（四个方向）的岛屿加入队列并标记为访问过。直至遍历到队列为空的时候，将岛屿数量+1。然后接着遍历二维数组剩余的位置，只要是被访问过的岛屿就会跳过，即不将其作为<code>源</code>进行BFS，只有碰到未访问过的岛屿，才会将其作为新的<code>源</code>进行下一个BFS。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rows = grid.length;</span><br><span class="line">        <span class="keyword">if</span>(rows == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> columns = grid[<span class="number">0</span>].length;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 岛屿数量</span></span><br><span class="line">        <span class="keyword">int</span> islandNum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// visited表示某点是否访问过</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][columns];</span><br><span class="line">        <span class="keyword">int</span>[] dx = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dy = &#123;<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;rows; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;columns; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="string">'1'</span> &amp;&amp; !visited[i][j])&#123;</span><br><span class="line">                    q.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);</span><br><span class="line">                    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">                        <span class="keyword">int</span> size = q.size();</span><br><span class="line">                        <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                            <span class="keyword">int</span>[] curr = q.poll();</span><br><span class="line">                            <span class="keyword">int</span> currX = curr[<span class="number">0</span>];</span><br><span class="line">                            <span class="keyword">int</span> currY = curr[<span class="number">1</span>];</span><br><span class="line">                            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">4</span>; k++)&#123;</span><br><span class="line">                                <span class="keyword">int</span> newX = currX + dx[k];</span><br><span class="line">                                <span class="keyword">int</span> newY = currY + dy[k];</span><br><span class="line">                               <span class="comment">// 只将不越界且未被访问的陆地('1')加入队列</span></span><br><span class="line">                                <span class="keyword">if</span>(newX&lt;<span class="number">0</span> || newX&gt;=rows || newY&lt;<span class="number">0</span> || newY&gt;=columns || visited[newX][newY] || grid[newX][newY]==<span class="string">'0'</span>)&#123;</span><br><span class="line">                                    <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                q.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;newX,newY&#125;);</span><br><span class="line">                                visited[newX][newY] = <span class="keyword">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 一个岛屿遍历完，岛屿数量+1</span></span><br><span class="line">                    islandNum +=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> islandNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="1-7-完全平方数-Leetcode-279"><a href="#1-7-完全平方数-Leetcode-279" class="headerlink" title="1.7 完全平方数  Leetcode-279"></a>1.7 完全平方数  Leetcode-279</h2><blockquote>
<p><strong>题目同3.1。此处用宽度优先搜索解决。</strong></p>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>将此题目抽象为，要从n走到0，每次跨越的距离只能为平方数，求最少的跨越次数。很自然用标准的BFS去解决。</p>
</blockquote>
<p>使用广度优先搜索方法，将 n 依次减去比 n 小的所有平方数，直至 n = 0 ，此时的层数即为最后的结果。</p>
<p><strong>动画演示</strong></p>
<p><img src="https://mmbiz.qlogo.cn/mmbiz_gif/D67peceibeISVzyopJgc0ZTiaCm5xWvaRfqzgkqo7WJcHziaic3yiaxjiaziaExuEfeuVvryxMRk9FQe16IERTDVcpvyw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1&retryload=2" alt="动画演示 Made by 王琛"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 标记某个数是否被访问过，比如上一层已经有了7，下一层如果再出现7，就忽略它，不将其放入该层</span></span><br><span class="line">        Set&lt;Integer&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        q.offer(n);</span><br><span class="line">        <span class="keyword">int</span> steps = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            <span class="comment">// 处理当前层</span></span><br><span class="line">            <span class="keyword">while</span> (size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> curr = q.poll();</span><br><span class="line">                <span class="comment">// 依次减去比当前数字小的平方数，结果放到下一层</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=(<span class="keyword">int</span>)Math.sqrt(curr); i++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = curr-i*i;</span><br><span class="line">                    <span class="comment">// 已访问过</span></span><br><span class="line">                    <span class="keyword">if</span>(visited.contains(tmp)) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">// 到了0，此时该层可能还没弄完，steps先加1，直接跳出</span></span><br><span class="line">                    <span class="keyword">if</span>(tmp == <span class="number">0</span>) <span class="keyword">return</span> ++steps;</span><br><span class="line">                    <span class="comment">// 加入队列</span></span><br><span class="line">                    q.offer(tmp);</span><br><span class="line">                    <span class="comment">// 标记访问过</span></span><br><span class="line">                    visited.add(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 一层结束，没到终点，步数加一</span></span><br><span class="line">            steps++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 该题中这步其实应该是用不到，只是程序完整性，需要加上</span></span><br><span class="line">        <span class="keyword">return</span> steps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-8-零钱兑换-Leetcode-322"><a href="#1-8-零钱兑换-Leetcode-322" class="headerlink" title="1.8 零钱兑换  Leetcode-322"></a>1.8 零钱兑换  Leetcode-322</h2><blockquote>
<p><img src="C:%5CUsers%5CSean%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200425154614401.png" alt="image-20200425154614401"></p>
</blockquote>
<p><strong>思路和题目1.7相同</strong></p>
<p>还是n走几步到0的问题，每一步只能减去coins里的数，求最短步数。</p>
<p><strong>BFS代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">BFS的运行时间比动态规划长</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">		Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.offer(amount);</span><br><span class="line">        <span class="keyword">int</span> steps = <span class="number">0</span>;</span><br><span class="line">        Set&lt;Integer&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> curr = q.poll();</span><br><span class="line">                <span class="keyword">if</span>(curr==<span class="number">0</span>) <span class="keyword">return</span> steps;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i: coins)&#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = curr - i;</span><br><span class="line">                    <span class="keyword">if</span>(visited.contains(tmp) || tmp&lt;<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    q.offer(tmp);</span><br><span class="line">                    visited.add(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            steps++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-9-二叉树的右视图-Leetcode-199"><a href="#1-9-二叉树的右视图-Leetcode-199" class="headerlink" title="1.9 二叉树的右视图  Leetcode-199"></a>1.9 二叉树的右视图  Leetcode-199</h2><p><strong>同题目<code>2.5</code></strong>，此处用的BFS，每一层最后访问最右的子节点，并将其加入结果列表</p>
<p><img src="C:%5CUsers%5CSean%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200426182509526.png" alt="image-20200426182509526"></p>
<p><strong>思路</strong></p>
<p>我们可以对二叉树进行层次遍历，那么对于每层来说，最右边的结点一定是最后被遍历到的。二叉树的层次遍历可以用广度优先搜索实现。</p>
<p><strong>算法</strong></p>
<p>执行广度优先搜索，左结点排在右结点之前，这样，我们对每一层都从左到右访问。因此，<strong>只保留每个深度最后访问的结点</strong>，我们就可以在遍历完整棵树后得到每个深度最右的结点。相较<code>2.5题DFS</code>，除了将栈改成队列，并去除了<code>rightmost_value_at_depth</code>之前的检查外，算法没有别的改动。</p>
<blockquote>
<p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/solution/er-cha-shu-de-you-shi-tu-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-right-side-view/solution/er-cha-shu-de-you-shi-tu-by-leetcode-solution/</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">                TreeNode curr = q.poll();</span><br><span class="line">                <span class="keyword">if</span>(curr.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    q.offer(curr.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(curr.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    q.offer(curr.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i==size-<span class="number">1</span>)&#123;</span><br><span class="line">                    res.add(curr.val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-10-迷宫最短路径-华为机试题"><a href="#1-10-迷宫最短路径-华为机试题" class="headerlink" title="1.10 迷宫最短路径  华为机试题"></a>1.10 迷宫最短路径  华为机试题</h2><p><strong>题目描述</strong></p>
<p>定义一个二维数组N*M（其中2&lt;=N&lt;=10;2&lt;=M&lt;=10），如5 × 5数组下所示： </p>
<p>int maze [5] [5]= {</p>
<p>​    0, 1, 0, 0, 0,</p>
<p>​    0, 1, 0, 1, 0,    </p>
<p>​    0, 0, 0, 0, 0,</p>
<p>​    0, 1, 1, 1, 0,</p>
<p>​    0, 0, 0, 1, 0,<br>};</p>
<p>它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。入口点为[0,0],既第一空格是可以走的路。</p>
<p><strong>输入</strong></p>
<p>一个N × M的二维数组，表示一个迷宫。数据保证有唯一解,不考虑有多解的情况，即迷宫只有一条通道。</p>
<p><strong>输出</strong></p>
<p>左上角到右下角的最短路径，格式如样例所示。</p>
<p><code>Sample Input</code></p>
<p>0 1 0 0 0</p>
<p>0 1 0 1 0</p>
<p>0 0 0 0 0</p>
<p>0 1 1 1 0</p>
<p>0 0 0 1 0</p>
<p><code>Sample Output</code></p>
<p>(0, 0)</p>
<p>(1, 0)</p>
<p>(2, 0)</p>
<p>(2, 1)</p>
<p>(2, 2)</p>
<p>(2, 3)</p>
<p>(2, 4)</p>
<p>(3, 4)</p>
<p>(4, 4)</p>
<p><strong>输入描述:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入两个整数，分别表示二位数组的行数，列数。再输入相应的数组，其中的1表示墙壁，0表示可以走的路。数据保证有唯一解,不考虑有多解的情况，即迷宫只有一条通道。</span><br></pre></td></tr></table></figure>

<p><strong>输出描述:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">左上角到右下角的最短路径，格式如样例所示。</span><br></pre></td></tr></table></figure>

<p>示例1</p>
<p><strong>输入</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 5</span><br><span class="line">0 1 0 0 0</span><br><span class="line">0 1 0 1 0</span><br><span class="line">0 0 0 0 0</span><br><span class="line">0 1 1 1 0</span><br><span class="line">0 0 0 1 0</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(0,0)</span><br><span class="line">(1,0)</span><br><span class="line">(2,0)</span><br><span class="line">(2,1)</span><br><span class="line">(2,2)</span><br><span class="line">(2,3)</span><br><span class="line">(2,4)</span><br><span class="line">(3,4)</span><br><span class="line">(4,4)</span><br></pre></td></tr></table></figure>

<p>这题是给定起点和终点，求迷宫最短路径，采用BFS。</p>
<p><strong>不同之处</strong>是要求<code>打印最短路径</code>。</p>
<blockquote>
<p>所以自定义了一个Node类（保存坐标信息及前驱结点（上一步）），每走一步，就记录当前结点的上一结点，最后找到终点的时候就可以由终点回溯至起点。</p>
<p>利用栈按照终点到起点的顺序压栈，再根据“后入先出”的性质依次出栈，就实现了路径的打印</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="comment">// 结点pre表示当前结点的前驱结点</span></span><br><span class="line">    <span class="keyword">public</span> Node pre;</span><br><span class="line">    <span class="comment">// pos存放当前结点的x和y坐标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] pos;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pos = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,Node pre)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pos = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;;</span><br><span class="line">        <span class="keyword">this</span>.pre = pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="comment">// 下、上、右、左四个方向</span></span><br><span class="line">        <span class="keyword">int</span>[] dx = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dy = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(sc.hasNextInt())&#123;</span><br><span class="line">            <span class="keyword">int</span> rows = sc.nextInt();<span class="comment">//行</span></span><br><span class="line">            <span class="keyword">int</span> columns = sc.nextInt();<span class="comment">//列</span></span><br><span class="line">            <span class="keyword">if</span>(rows==<span class="number">0</span>||columns==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span>[][] maze = <span class="keyword">new</span> <span class="keyword">int</span>[rows][columns];</span><br><span class="line">            <span class="comment">// 迷宫矩阵初始化</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows ; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; j++) &#123;</span><br><span class="line">                    maze[i][j] = sc.nextInt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 开始</span></span><br><span class="line">            <span class="keyword">if</span>(maze[<span class="number">0</span>][<span class="number">0</span>]!=<span class="number">0</span>||maze[rows-<span class="number">1</span>][columns-<span class="number">1</span>]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 队列实现BFS（宽度优先搜索）</span></span><br><span class="line">            Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="comment">// 将搜索起点加入队列，完成队列初始化</span></span><br><span class="line">            queue.add(<span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">int</span> size = queue.size();</span><br><span class="line">                <span class="comment">// 这个while循环保证了宽度优先搜索</span></span><br><span class="line">                <span class="comment">// 即先将当前层的结点都访问一遍，循环次数就是size，当前层的结点个数</span></span><br><span class="line">                <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// 队列头弹出结点</span></span><br><span class="line">                    Node node = queue.poll();</span><br><span class="line">                    <span class="keyword">int</span> curX = node.pos[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> curY = node.pos[<span class="number">1</span>];</span><br><span class="line">                    <span class="comment">// 标记该结点被访问过，采取方式是直接在原矩阵上修改数值，这里改为与0和1都不冲突的2</span></span><br><span class="line">                    maze[curX][curY] = <span class="number">2</span>;</span><br><span class="line">                    <span class="comment">// 在当前结点向四个方向搜索</span></span><br><span class="line">                    <span class="comment">// 每个方向走一步，先判断是否到了目标点。</span></span><br><span class="line">                    <span class="comment">// 若没有到达，则对该结点执行有效性检查，符合要求才添加进队列</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                        <span class="keyword">int</span> newX = curX + dx[k];</span><br><span class="line">                        <span class="keyword">int</span> newY = curY + dy[k];</span><br><span class="line">                        <span class="comment">// 某个方向到达目标点</span></span><br><span class="line">                        <span class="keyword">if</span>(newX == rows-<span class="number">1</span> &amp;&amp; newY == columns-<span class="number">1</span>)&#123;</span><br><span class="line">                            Node endNode = <span class="keyword">new</span> Node(newX,newY,node);</span><br><span class="line">                            printNode(endNode);</span><br><span class="line">                            <span class="comment">// 这里有多重循环，且没有返回值，不能return</span></span><br><span class="line">                            <span class="comment">// 只有将size置0，清空队列，才能在接下来跳出两层循环</span></span><br><span class="line">                            size = <span class="number">0</span>;</span><br><span class="line">                            queue.clear();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 某个方向未到达目标，执行有效性检查，索引不越界且该结点可走才有资格添加进队列</span></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(newX &gt;=<span class="number">0</span> &amp;&amp; newY &gt;=<span class="number">0</span> &amp;&amp; newX&lt; rows &amp;&amp; newY &lt; columns &amp;&amp; maze[newX][newY] == <span class="number">0</span>)&#123;</span><br><span class="line">                            <span class="comment">// 这里一定要将前驱结点node加上</span></span><br><span class="line">                            Node next = <span class="keyword">new</span> Node(newX,newY,node);</span><br><span class="line">                            queue.add(next);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印最终路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNode</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 把路径上的结点从后向前入栈</span></span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">            node = node.pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再将栈中的结点依次弹出并输出，基于后入先出</span></span><br><span class="line">        <span class="comment">// 就实现了路径的正序打印</span></span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            Node n = stack.pop();</span><br><span class="line">            System.out.println(<span class="string">"("</span>+n.pos[<span class="number">0</span>]+<span class="string">","</span>+n.pos[<span class="number">1</span>]+<span class="string">")"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-11-跳跃游戏II-Leetcode-45（Hard）"><a href="#1-11-跳跃游戏II-Leetcode-45（Hard）" class="headerlink" title="1.11 跳跃游戏II  Leetcode-45（Hard）"></a>1.11 跳跃游戏II  Leetcode-45（Hard）</h2><p><a href="https://leetcode-cn.com/problems/jump-game-ii/" target="_blank" rel="noopener">45. 跳跃游戏 II</a></p>
<p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,1,1,4]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 2。</span><br><span class="line">     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="comment">//bfs找到最快到达n-1的</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];<span class="comment">//记录是否使用过</span></span><br><span class="line">        used[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            res ++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ; i &lt; size; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> index = queue.poll();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = nums[index]; j &gt; <span class="number">0</span>; j--)&#123;<span class="comment">//从大到小,一种贪心,一定程度提高效率,没有这个策略会超时</span></span><br><span class="line">                    <span class="keyword">if</span>(j + index &gt;= n-<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> res;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(!used[j + index])&#123;</span><br><span class="line">                        queue.add(j + index);</span><br><span class="line">                        used[j+index] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="2-DFS（深度优先搜索）"><a href="#2-DFS（深度优先搜索）" class="headerlink" title="2  DFS（深度优先搜索）"></a>2  DFS（深度优先搜索）</h1><h2 id="2-1-机器人的运动范围-面试题-13"><a href="#2-1-机器人的运动范围-面试题-13" class="headerlink" title="2.1 机器人的运动范围  面试题-13"></a>2.1 机器人的运动范围  面试题-13</h2><p><img src="C:%5CUsers%5CSean%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200423220008156.png" alt="image-20200423220008156"></p>
<p>作者：jyd<br>链接：<a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/solution/mian-shi-ti-13-ji-qi-ren-de-yun-dong-fan-wei-dfs-b/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/solution/mian-shi-ti-13-ji-qi-ren-de-yun-dong-fan-wei-dfs-b/</a></p>
<p><strong>思路：</strong></p>
<p>本题同1.4相同。只是这里采用深度优先搜索 DFS实现。</p>
<ul>
<li><p><strong>深度优先搜索</strong>： 可以理解为暴力法模拟机器人在矩阵中的所有路径。DFS通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。</p>
</li>
<li><p><strong>剪枝</strong>： 在搜索中，遇到数位和超出目标值、此元素已访问，则应立即返回，称之为 可行性剪枝 。</p>
</li>
<li><p><strong>隐藏的优化</strong>：我们在搜索的过程中搜索方向可以缩减为向右和向下，而不必再向上和向左进行搜索。如下图，我们展示了 16 * 16 的地图随着限制条件 k 的放大，可行方格的变化趋势，每个格子里的值为行坐标和列坐标的数位之和，蓝色方格代表非障碍方格，即其值小于等于当前的限制条件 k。我们可以发现随着限制条件 k 的增大，(0, 0) 所在的蓝色方格区域内新加入的非障碍方格都可以由上方或左方的格子移动一步得到。而其他不连通的蓝色方格区域会随着 k 的增大而连通，且连通的时候也是由上方或左方的格子移动一步得到，因此我们可以将我们的<strong>搜索方向缩减为向右或向下</strong>。</p>
<p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/solution/ji-qi-ren-de-yun-dong-fan-wei-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/solution/ji-qi-ren-de-yun-dong-fan-wei-by-leetcode-solution/</a></p>
</li>
</ul>
<p>算法解析：</p>
<ul>
<li><strong>递归参数</strong>： 当前元素在矩阵中的行列索引 i 和 j ，两者的数位和digitSum 。</li>
<li><strong>终止条件</strong>： 当 ① 行列索引越界  或  ② 数位和超出目标值 k  或  ③ 当前元素已访问过时，返回 0，代表不计入可达解。</li>
<li><strong>递推工作</strong>：<ul>
<li>标记当前单元格 ：将索引 (i, j) 存入 Set ‘visited’ 中，代表此单元格已被访问过。</li>
<li>搜索下一单元格： 计算当前元素的 下、右 两个方向元素的数位和，并开启下层递归 。</li>
</ul>
</li>
<li><strong>回溯返回值</strong>： 返回 1 + 右方搜索的可达解总数 + 下方搜索的可达解总数，代表从本单元格递归搜索的可达解总数。</li>
</ul>
<p><strong>复杂度分析：</strong><br>M, N 分别为矩阵行列大小。</p>
<ul>
<li>时间复杂度 O(MN)： 最差情况下，机器人遍历矩阵所有单元格，此时时间复杂度为 O(MN)。</li>
<li>空间复杂度 O(MN) ： 最差情况下，Set visited 内存储矩阵所有单元格的索引，使用 O(MN) 的额外空间。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n, k;</span><br><span class="line">    <span class="keyword">boolean</span>[][] visited;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.m = m; <span class="keyword">this</span>.n = n; <span class="keyword">this</span>.k = k;</span><br><span class="line">        <span class="comment">// visited标记每个单元格是否被访问过，默认初始化为false</span></span><br><span class="line">        <span class="keyword">this</span>.visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// i和j是单元格的行列索引，digitSum是单元格行列索引各位数字之和</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> digitSum)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 该单元格越界/被访问过/不符合要求</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= m || j &gt;= n || k &lt; digitSum || visited[i][j]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 递归搜索右方和下方可行解（见上方搜索方向的优化，可忽略上和左方向）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + dfs(i + <span class="number">1</span>, j, getDigitSum(i+<span class="number">1</span>,j)) + dfs(i, j + <span class="number">1</span>, getDigitSum(i,j+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDigitSum</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            sum += i%<span class="number">10</span>;</span><br><span class="line">            i /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            sum += j%<span class="number">10</span>;</span><br><span class="line">            j /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-2-岛屿的最大面积-Leetcode-695"><a href="#2-2-岛屿的最大面积-Leetcode-695" class="headerlink" title="2.2 岛屿的最大面积  Leetcode-695"></a>2.2 岛屿的最大面积  Leetcode-695</h2><p><img src="C:%5CUsers%5CSean%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200424154203050.png" alt="image-20200424154203050"></p>
<h4 id="算法1：递归-深度优先遍历"><a href="#算法1：递归-深度优先遍历" class="headerlink" title="算法1：递归 + 深度优先遍历"></a>算法1：递归 + 深度优先遍历</h4><ul>
<li>我们想知道网格中每个连通形状的面积，然后取最大值。</li>
</ul>
<ul>
<li>如果我们在一个土地上，以 4 个方向探索与之相连的每一个土地（以及与这些土地相连的土地），那么探索过的土地总数将是该连通形状的面积。</li>
</ul>
<ul>
<li>为了确保每个土地访问不超过一次，我们每次经过一块土地时，将这块土地的值置为 0。这样我们就不会多次访问同一土地。</li>
</ul>
<p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode-cn.com/problems/max-area-of-island/solution/dao-yu-de-zui-da-mian-ji-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/max-area-of-island/solution/dao-yu-de-zui-da-mian-ji-by-leetcode-solution/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>; </span><br><span class="line">        <span class="comment">// 求的是岛屿的最大面积</span></span><br><span class="line">        <span class="comment">// 先将每个岛屿的面积求出来，然后取最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    res = Math.max(res, dfs(i, j, grid));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每次调用的时候默认num为1，进入后判断如果不是岛屿，则直接返回0，就可以避免预防错误的情况。</span></span><br><span class="line">    <span class="comment">// 为了确保每个土地访问不超过一次，我们每次经过一块土地时，将这块土地的值置为 0。这样我们就不会多次访问同一土地。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= grid.length || j &gt;= grid[i].length || grid[i][j] == <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        grid[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 递归DFS</span></span><br><span class="line">        <span class="comment">// 先向下</span></span><br><span class="line">        num += dfs(i + <span class="number">1</span>, j, grid);</span><br><span class="line">        <span class="comment">// 下的搜索完后再向上</span></span><br><span class="line">        num += dfs(i - <span class="number">1</span>, j, grid);</span><br><span class="line">        <span class="comment">// 右</span></span><br><span class="line">        num += dfs(i, j + <span class="number">1</span>, grid);</span><br><span class="line">        <span class="comment">// 左</span></span><br><span class="line">        num += dfs(i, j - <span class="number">1</span>, grid);</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="算法2：栈-深度优先遍历"><a href="#算法2：栈-深度优先遍历" class="headerlink" title="算法2：栈 + 深度优先遍历"></a>算法2：栈 + 深度优先遍历</h4><p><strong>解题思路</strong></p>
<p>通过栈实现深度优先遍历，和解法一类似，只是把递归变为了栈。</p>
<p>作者：wang_dong<br>链接：<a href="https://leetcode-cn.com/problems/max-area-of-island/solution/javaban-3chong-jie-fa-by-wang_dong/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/max-area-of-island/solution/javaban-3chong-jie-fa-by-wang_dong/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        Stack&lt;<span class="keyword">int</span>[]&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rows = grid.length;</span><br><span class="line">        <span class="keyword">int</span> columns = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[] dx = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dy = &#123;<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;; </span><br><span class="line">        <span class="comment">// 遍历矩阵，对每一个方格执行深度优先搜索</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;rows; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;columns; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                stack.push(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);</span><br><span class="line">                <span class="comment">// 不能初始化为1，因为这个&#123;i,j&#125;的陆地会在后面加上</span></span><br><span class="line">                <span class="keyword">int</span> currArea = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 这个while循环跳出后，得到的currArea就是当前陆地及附近所构成的陆地总面积</span></span><br><span class="line">                <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">                    <span class="keyword">int</span>[] curr = stack.pop();</span><br><span class="line">                    <span class="keyword">int</span> currX = curr[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> currY = curr[<span class="number">1</span>];</span><br><span class="line">                    <span class="comment">// 非法或者是海洋（包含已访问）</span></span><br><span class="line">                    <span class="keyword">if</span>(currX &lt; <span class="number">0</span> || currX &gt;= rows || currY&lt;<span class="number">0</span> || currY&gt;=columns || grid[currX][currY]!=<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 将陆地标为海洋，表示已访问过</span></span><br><span class="line">                    grid[currX][currY] = <span class="number">0</span>;</span><br><span class="line">                    <span class="comment">// 面积加1</span></span><br><span class="line">                    currArea += <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">4</span>; k++)&#123;</span><br><span class="line">                        <span class="keyword">int</span> newX = currX + dx[k];</span><br><span class="line">                        <span class="keyword">int</span> newY = currY + dy[k];</span><br><span class="line">                        stack.push(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;newX,newY&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 栈为空，跳出while循环，表明当前陆地相邻的所有陆地都遍历完，面积为currArea</span></span><br><span class="line">                <span class="comment">// 此时更新全局的maxArea</span></span><br><span class="line">                maxArea = Math.max(maxArea,currArea);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-3-岛屿数量-Leetcode-200"><a href="#2-3-岛屿数量-Leetcode-200" class="headerlink" title="2.3 岛屿数量  Leetcode-200"></a>2.3 岛屿数量  Leetcode-200</h2><img src="C:\Users\Sean\AppData\Roaming\Typora\typora-user-images\image-20200425175838468.png" alt="image-20200425175838468"  />



<p>同题目<code>1.6.5</code>，此处使用<code>DFS</code>（深度优先搜索）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法一：深度优先遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//           x-1,y</span></span><br><span class="line">    <span class="comment">//  x,y-1    x,y      x,y+1</span></span><br><span class="line">    <span class="comment">//           x+1,y</span></span><br><span class="line">    <span class="comment">// 方向数组，它表示了相对于当前位置的 4 个方向的横、纵坐标的偏移量，这是一个常见的技巧</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[][] directions = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">// 标记数组，标记了 grid 的坐标对应的格子是否被访问过</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[][] marked;</span><br><span class="line">    <span class="comment">// grid 的行数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rows;</span><br><span class="line">    <span class="comment">// grid 的列数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cols;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[][] grid;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        rows = grid.length;</span><br><span class="line">        <span class="keyword">if</span> (rows == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cols = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">this</span>.grid = grid;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="comment">// 如果是岛屿中的一个点，并且没有被访问过</span></span><br><span class="line">                <span class="comment">// 就进行深度优先遍历，将连接的其他陆地都标记为访问过</span></span><br><span class="line">                <span class="keyword">if</span> (!marked[i][j] &amp;&amp; grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    <span class="comment">// 岛屿数量加1</span></span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="comment">// 从(i,j)位置处DFS</span></span><br><span class="line">                    dfs(i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从坐标为 (i,j) 的点开始进行深度优先遍历</span></span><br><span class="line">    <span class="comment">// 其作用就是将被遍历到的岛屿标记为访问过</span></span><br><span class="line">    <span class="comment">// 递归DFS</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        marked[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 得到 4 个方向的坐标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">int</span> newX = i + directions[k][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> newY = j + directions[k][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 如果不越界、没有被访问过、并且还要是陆地，则继续DFS</span></span><br><span class="line">            <span class="keyword">if</span> (inArea(newX, newY) &amp;&amp; grid[newX][newY] == <span class="string">'1'</span> &amp;&amp; !marked[newX][newY]) &#123;</span><br><span class="line">                dfs(newX, newY);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装成 inArea 方法语义更清晰</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 等于号不要忘了</span></span><br><span class="line">        <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; cols;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="keyword">char</span>[][] grid1 = &#123;</span><br><span class="line">                &#123;<span class="string">'1'</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="string">'0'</span>&#125;,</span><br><span class="line">                &#123;<span class="string">'1'</span>, <span class="string">'1'</span>, <span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'0'</span>&#125;,</span><br><span class="line">                &#123;<span class="string">'1'</span>, <span class="string">'1'</span>, <span class="string">'0'</span>, <span class="string">'0'</span>, <span class="string">'0'</span>&#125;,</span><br><span class="line">                &#123;<span class="string">'0'</span>, <span class="string">'0'</span>, <span class="string">'0'</span>, <span class="string">'0'</span>, <span class="string">'0'</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> numIslands1 = solution.numIslands(grid1);</span><br><span class="line">        System.out.println(numIslands1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[][] grid2 = &#123;</span><br><span class="line">                &#123;<span class="string">'1'</span>, <span class="string">'1'</span>, <span class="string">'0'</span>, <span class="string">'0'</span>, <span class="string">'0'</span>&#125;,</span><br><span class="line">                &#123;<span class="string">'1'</span>, <span class="string">'1'</span>, <span class="string">'0'</span>, <span class="string">'0'</span>, <span class="string">'0'</span>&#125;,</span><br><span class="line">                &#123;<span class="string">'0'</span>, <span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'0'</span>, <span class="string">'0'</span>&#125;,</span><br><span class="line">                &#123;<span class="string">'0'</span>, <span class="string">'0'</span>, <span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'1'</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> numIslands2 = solution.numIslands(grid2);</span><br><span class="line">        System.out.println(numIslands2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：liweiwei1419</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/number-of-islands/solution/dfs-bfs-bing-cha-ji-python-dai-ma-java-dai-ma-by-l/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>



<h2 id="2-4-单词搜索-Leetcode-79（Medium）"><a href="#2-4-单词搜索-Leetcode-79（Medium）" class="headerlink" title="2.4 单词搜索  Leetcode-79（Medium）"></a>2.4 单词搜索  Leetcode-79（Medium）</h2><p><img src="C:%5CUsers%5CSean%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200426100011470.png" alt="image-20200426100011470"></p>
<blockquote>
<p>本题用<code>DFS+回溯</code>，用BFS不太方便（捣鼓了好久）</p>
</blockquote>
<p><a href="https://leetcode-cn.com/problems/word-search/solution/zai-er-wei-ping-mian-shang-shi-yong-hui-su-fa-pyth/" target="_blank" rel="noopener">参考解答链接</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这些定义为类的成员变量方便后面的dfs调用</span></span><br><span class="line">    <span class="keyword">int</span>[] dx = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] dy = &#123;<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> rows;</span><br><span class="line">    <span class="keyword">int</span> columns;</span><br><span class="line">    <span class="keyword">boolean</span>[][] visited;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] charArr = word.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> rows = board.length;</span><br><span class="line">        <span class="keyword">if</span>(rows == <span class="number">0</span> || word.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> columns = board[<span class="number">0</span>].length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">this</span>.rows = rows;</span><br><span class="line">        <span class="keyword">this</span>.columns = columns;</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][columns];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;rows; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;columns; j++)&#123;</span><br><span class="line">                <span class="comment">// 不能直接return dfs(board,charArr,i,j,0);</span></span><br><span class="line">                <span class="comment">// 那样只会对(0,0)开始搜索一次，无论true或者false，搜索完就结束</span></span><br><span class="line">                <span class="keyword">if</span>(dfs(board,charArr,i,j,<span class="number">0</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在board的(i,j)位置开始搜索目标word在index位置及之后的字符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">char</span>[] charArr, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 递归的边界</span></span><br><span class="line">        <span class="keyword">if</span>(index==charArr.length-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> board[i][j] == charArr[charArr.length-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等于才进行后续搜索，否则往下搜索没意义，直接返回false</span></span><br><span class="line">        <span class="keyword">if</span>(board[i][j] == charArr[index])&#123;</span><br><span class="line">            <span class="comment">// 标记访问过</span></span><br><span class="line">            visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 在四个方向上递归搜索</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">4</span>; k++)&#123;</span><br><span class="line">                <span class="keyword">int</span> newX = i+dx[k];</span><br><span class="line">                <span class="keyword">int</span> newY = j+dy[k];</span><br><span class="line">                <span class="keyword">if</span>(newX&gt;=<span class="number">0</span> &amp;&amp; newX&lt;rows &amp;&amp; newY&gt;=<span class="number">0</span> &amp;&amp; newY&lt;columns &amp;&amp; !visited[newX][newY])&#123;</span><br><span class="line">                    <span class="comment">// 每个方向上如果能成功到目的地，则直接返回true。否则到下一方向试试</span></span><br><span class="line">                    <span class="keyword">if</span>(dfs(board,charArr,newX,newY,index+<span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重要！当前位置的四个方向都搜索失败，则将当前位置访问状态重置。一定要重置</span></span><br><span class="line">        <span class="comment">// 因为当前位置从index位置处搜索失败，但可能在后面的index处能搜索成功。</span></span><br><span class="line">        <span class="comment">// 四分方向均搜索失败，返回false</span></span><br><span class="line">        visited[i][j] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>顺带附上我的BFS尝试失败的代码吧</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] charArr = word.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> rows = board.length;</span><br><span class="line">        <span class="keyword">if</span>(rows == <span class="number">0</span> || word.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> columns = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][columns];</span><br><span class="line">        <span class="keyword">int</span>[] dx = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dy = &#123;<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;rows; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;columns; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == charArr[<span class="number">0</span>])&#123;</span><br><span class="line">                    q.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);</span><br><span class="line">                    visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">while</span> (!q.isEmpty())&#123;</span><br><span class="line">                        <span class="keyword">int</span> size = q.size();</span><br><span class="line">                        <span class="keyword">boolean</span> hasNext = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                            index++;</span><br><span class="line">                            <span class="keyword">if</span> (index == charArr.length) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                            <span class="keyword">int</span>[] curr = q.poll();</span><br><span class="line">                            <span class="keyword">int</span> currX = curr[<span class="number">0</span>];</span><br><span class="line">                            <span class="keyword">int</span> currY = curr[<span class="number">1</span>];</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                                <span class="keyword">int</span> newX = currX + dx[k];</span><br><span class="line">                                <span class="keyword">int</span> newY = currY + dy[k];</span><br><span class="line">                                <span class="keyword">if</span> (newX&lt;<span class="number">0</span> || newX&gt;=rows || newY&lt;<span class="number">0</span> || newY&gt;=columns</span><br><span class="line">                                        || visited[newX][newY] || board[newX][newY]!=charArr[index])&#123;</span><br><span class="line">                                    <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">//if (index == charArr.length-1) return true;</span></span><br><span class="line">                                q.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;newX,newY&#125;);</span><br><span class="line">                                <span class="comment">// 错就错在这，比如某层搜索的时候有两个符合要求，都被标记为访问过加入下一层，但是在下一层遍历的时候其中一个的四周没有符合条件的数字，按道理应该将其访问状态重置，即恢复为false。但是我这里没法重置状态，导致后面的搜索碰到该点会因为其被标记为访问过而跳过，导致最后本可以有路径确输出false</span></span><br><span class="line">                                visited[newX][newY] = <span class="keyword">true</span>;</span><br><span class="line">                                hasNext = <span class="keyword">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            index--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(hasNext) index++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][columns];</span><br><span class="line">                index = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-5-二叉树的右视图-Leetcode-199"><a href="#2-5-二叉树的右视图-Leetcode-199" class="headerlink" title="2.5 二叉树的右视图  Leetcode-199"></a>2.5 二叉树的右视图  Leetcode-199</h2><p><strong>同题目<code>1.9</code></strong></p>
<p><img src="C:%5CUsers%5CSean%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200426182509526.png" alt="image-20200426182509526"></p>
<p><strong>解法1：递归DFS</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> res;     </span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">1</span>;</span><br><span class="line">        dfs(root,depth);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//其实就是前序遍历，先访问根节点，接着访问右子树，然后访问左子树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode node, <span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 递归边界条件</span></span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前节点的深度是现有深度的下一层，则将当前节点的val加入res</span></span><br><span class="line">        <span class="comment">// 否则表明当前节点所在的层已经将最右边的结点加入res了</span></span><br><span class="line">        <span class="keyword">if</span>(depth==res.size()+<span class="number">1</span>)&#123;</span><br><span class="line">            res.add(node.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 往下，深度加1</span></span><br><span class="line">        depth++;</span><br><span class="line">        <span class="comment">// 先访问右子树</span></span><br><span class="line">        dfs(node.right,depth);</span><br><span class="line">        <span class="comment">// 后访问左子树</span></span><br><span class="line">        dfs(node.left,depth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>解法2：栈 + DFS</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; rightmostValueAtDepth = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> max_depth = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        Stack&lt;TreeNode&gt; nodeStack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; depthStack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        nodeStack.push(root);</span><br><span class="line">        depthStack.push(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!nodeStack.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = nodeStack.pop();</span><br><span class="line">            <span class="keyword">int</span> depth = depthStack.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            	<span class="comment">// 维护二叉树的最大深度</span></span><br><span class="line">                max_depth = Math.max(max_depth, depth);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果不存在对应深度的节点我们才插入</span></span><br><span class="line">                <span class="keyword">if</span> (!rightmostValueAtDepth.containsKey(depth)) &#123;</span><br><span class="line">                    rightmostValueAtDepth.put(depth, node.val);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 根据栈“后入先出”，我们先将左节点压栈，再将右节点压栈，这样</span></span><br><span class="line">                <span class="comment">// 这样在下一次pop的时候先弹出右子节点</span></span><br><span class="line">                nodeStack.push(node.left);</span><br><span class="line">                nodeStack.push(node.right);</span><br><span class="line">                depthStack.push(depth+<span class="number">1</span>);</span><br><span class="line">                depthStack.push(depth+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; rightView = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> depth = <span class="number">0</span>; depth &lt;= max_depth; depth++) &#123;</span><br><span class="line">            rightView.add(rightmostValueAtDepth.get(depth));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rightView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/binary-tree-right-side-view/solution/er-cha-shu-de-you-shi-tu-by-leetcode-solution/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>



<h2 id="2-6-24点游戏-Leetcode-679"><a href="#2-6-24点游戏-Leetcode-679" class="headerlink" title="2.6 24点游戏  Leetcode-679"></a>2.6 24点游戏  Leetcode-679</h2><p><img src="C:%5CUsers%5CSean%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200427094724254.png" alt="image-20200427094724254"></p>
<p><strong>思想</strong></p>
<p><strong><code>DFS+回溯</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgePoint24</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Double&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            list.add((<span class="keyword">double</span>) i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次dfs都是选取两张牌,list里存放了要处理的数字，为待处理列表，长度不断变小</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(List&lt;Double&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果此时list只剩下了一张牌</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            因为float的精度问题，比如</span></span><br><span class="line"><span class="comment">             8/3=2.6666...</span></span><br><span class="line"><span class="comment">			 3 - 8/3 = 0.333...</span></span><br><span class="line"><span class="comment">			 8/0.333=23.999...</span></span><br><span class="line"><span class="comment">			 最后的结果和24会有些出入</span></span><br><span class="line"><span class="comment">			 所以这里对精度的处理是只要结果和24相差不超过0.001，即认为通过</span></span><br><span class="line"><span class="comment">			 这个精度的设置取决于测试用例，可能还会再小点</span></span><br><span class="line"><span class="comment">            */</span> </span><br><span class="line">            <span class="keyword">if</span> (Math.abs(list.get(<span class="number">0</span>)- <span class="number">24.0</span>) &lt; <span class="number">0.001</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 两层for循环表示选取两张牌</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; list.size(); j++) &#123;</span><br><span class="line">                <span class="comment">// 对于每下一个可能的产生的组合，每次处理一个</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">double</span> c : compute(list.get(i), list.get(j))) &#123;</span><br><span class="line">                    <span class="comment">// 每要处理一个新产生的数字，就重新定义下一轮待处理数字列表</span></span><br><span class="line">                    <span class="comment">// 这个重新定义的操作就满足了“回溯”</span></span><br><span class="line">                    List&lt;Double&gt; nextRound = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    <span class="comment">// 将它加入到下一轮待处理列表中</span></span><br><span class="line">                    nextRound.add(c);</span><br><span class="line">                    <span class="comment">// 接下来要选择的数不能是已经被选择的两个数,即索引不能是i和j</span></span><br><span class="line">                    <span class="comment">// 将其加入待处理列表nextRound</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; list.size(); k++) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(k == j || k == i) <span class="keyword">continue</span>;</span><br><span class="line">                        nextRound.add(list.get(k));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 递归处理该下一轮</span></span><br><span class="line">                    <span class="comment">// 如果成功，直接return true，结束程序</span></span><br><span class="line">                    <span class="comment">// 否则，进入下一次for循环</span></span><br><span class="line">                    <span class="keyword">if</span>(dfs(nextRound)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算下一个可能产生的组合</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;Double&gt; <span class="title">compute</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 两个数“+”，“-”，“*”，“/”的所有结果</span></span><br><span class="line">        List&lt;Double&gt; res = Arrays.asList(a + b,a-b,b-a,a*b,a/b,b/a);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="4-回溯"><a href="#4-回溯" class="headerlink" title="4  回溯"></a>4  回溯</h1><h2 id="4-1-24点游戏-Leetcode-679"><a href="#4-1-24点游戏-Leetcode-679" class="headerlink" title="4.1 24点游戏  Leetcode-679"></a>4.1 24点游戏  Leetcode-679</h2><p><img src="C:%5CUsers%5CSean%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200427094724254.png" alt="image-20200427094724254"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgePoint24</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Double&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            list.add((<span class="keyword">double</span>) i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次dfs都是选取两张牌,list里存放了要处理的数字，为待处理列表，长度不断变小</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(List&lt;Double&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果此时list只剩下了一张牌</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            因为float的精度问题，比如</span></span><br><span class="line"><span class="comment">             8/3=2.6666...</span></span><br><span class="line"><span class="comment">			 3 - 8/3 = 0.333...</span></span><br><span class="line"><span class="comment">			 8/0.333=23.999...</span></span><br><span class="line"><span class="comment">			 最后的结果和24会有些出入</span></span><br><span class="line"><span class="comment">			 所以这里对精度的处理是只要结果和24相差不超过0.001，即认为通过</span></span><br><span class="line"><span class="comment">			 这个精度的设置取决于测试用例，可能还会再小点</span></span><br><span class="line"><span class="comment">            */</span> </span><br><span class="line">            <span class="keyword">if</span> (Math.abs(list.get(<span class="number">0</span>)- <span class="number">24.0</span>) &lt; <span class="number">0.001</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 两层for循环表示选取两张牌</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; list.size(); j++) &#123;</span><br><span class="line">                <span class="comment">// 对于每下一个可能的产生的组合，每次处理一个</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">double</span> c : compute(list.get(i), list.get(j))) &#123;</span><br><span class="line">                    <span class="comment">// 每要处理一个新产生的数字，就重新定义下一轮待处理数字列表</span></span><br><span class="line">                    <span class="comment">// 这个重新定义的操作就满足了“回溯”</span></span><br><span class="line">                    List&lt;Double&gt; nextRound = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    <span class="comment">// 将它加入到下一轮待处理列表中</span></span><br><span class="line">                    nextRound.add(c);</span><br><span class="line">                    <span class="comment">// 接下来要选择的数不能是已经被选择的两个数,即索引不能是i和j</span></span><br><span class="line">                    <span class="comment">// 将其加入待处理列表nextRound</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; list.size(); k++) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(k == j || k == i) <span class="keyword">continue</span>;</span><br><span class="line">                        nextRound.add(list.get(k));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 递归处理该下一轮</span></span><br><span class="line">                    <span class="comment">// 如果成功，直接return true，结束程序</span></span><br><span class="line">                    <span class="comment">// 否则，进入下一次for循环</span></span><br><span class="line">                    <span class="keyword">if</span>(dfs(nextRound)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算下一个可能产生的组合</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;Double&gt; <span class="title">compute</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 两个数“+”，“-”，“*”，“/”的所有结果</span></span><br><span class="line">        List&lt;Double&gt; res = Arrays.asList(a + b,a-b,b-a,a*b,a/b,b/a);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-2-数独-Leetcode-37（Hard）"><a href="#4-2-数独-Leetcode-37（Hard）" class="headerlink" title="4.2 数独  Leetcode-37（Hard）"></a>4.2 数独  Leetcode-37（Hard）</h2><p>编写一个程序，通过已填充的空格来解决数独问题。</p>
<p>一个数独的解法需<strong>遵循如下规则</strong>：</p>
<ol>
<li>数字 <code>1-9</code> 在每一行只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一列只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。</li>
</ol>
<p>空白格用 <code>&#39;.&#39;</code> 表示。</p>
<p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt="img"></p>
<p>一个数独。</p>
<p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png" alt="img"></p>
<p>答案被标成红色。</p>
<p><strong>Note:</strong></p>
<ul>
<li>给定的数独序列只包含数字 <code>1-9</code> 和字符 <code>&#39;.&#39;</code> 。</li>
<li>你可以假设给定的数独只有唯一解。</li>
<li>给定数独永远是 <code>9x9</code> 形式的。</li>
</ul>
<p><strong>代码1</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 记录某行，某位数字是否已经被摆放</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] row = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 记录某列，某位数字是否已经被摆放</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] col = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 记录某 3x3 宫格内，某位数字是否已经被摆放</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] block = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">'.'</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> num = board[i][j] - <span class="string">'1'</span>;</span><br><span class="line">                    row[i][num] = <span class="keyword">true</span>;</span><br><span class="line">                    col[j][num] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">// blockIndex = i / 3 * 3 + j / 3，取整</span></span><br><span class="line">                    block[i / <span class="number">3</span> * <span class="number">3</span> + j / <span class="number">3</span>][num] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(board, row, col, block, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">boolean</span>[][] row, <span class="keyword">boolean</span>[][] col, <span class="keyword">boolean</span>[][] block, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 找寻空位置</span></span><br><span class="line">        <span class="keyword">while</span> (board[i][j] != <span class="string">'.'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (++j &gt;= <span class="number">9</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">9</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">0</span>; num &lt; <span class="number">9</span>; num++) &#123;</span><br><span class="line">            <span class="keyword">int</span> blockIndex = i / <span class="number">3</span> * <span class="number">3</span> + j / <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span> (!row[i][num] &amp;&amp; !col[j][num] &amp;&amp; !block[blockIndex][num]) &#123;</span><br><span class="line">                <span class="comment">// 递归</span></span><br><span class="line">                board[i][j] = (<span class="keyword">char</span>) (<span class="string">'1'</span> + num);</span><br><span class="line">                row[i][num] = <span class="keyword">true</span>;</span><br><span class="line">                col[j][num] = <span class="keyword">true</span>;</span><br><span class="line">                block[blockIndex][num] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (dfs(board, row, col, block, i, j)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 回溯</span></span><br><span class="line">                    row[i][num] = <span class="keyword">false</span>;</span><br><span class="line">                    col[j][num] = <span class="keyword">false</span>;</span><br><span class="line">                    block[blockIndex][num] = <span class="keyword">false</span>;</span><br><span class="line">                    board[i][j] = <span class="string">'.'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printBoard</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">                System.out.print(board[i][j] + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>方法2</strong>（回溯Backtrack   By-labuladong大神）</p>
<p><code>参考链接</code></p>
<p><a href="https://leetcode-cn.com/problems/sudoku-solver/solution/zi-cong-wo-xue-hui-liao-hui-su-suan-fa-zhong-yu-hu/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sudoku-solver/solution/zi-cong-wo-xue-hui-liao-hui-su-suan-fa-zhong-yu-hu/</a></p>
<p><strong>困惑</strong>：代码断里的<code>return</code> <strong>不清楚什么时候该用？怎么用？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        backtrack(board,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 找到一个可行解，触发 base case,从而终止函数</span></span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">9</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 穷举到最后一列的话就换到下一行重新开始。</span></span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">9</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> backtrack(board,i+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有预设数字，不用我们穷举</span></span><br><span class="line">        <span class="keyword">if</span>(board[i][j]!=<span class="string">'.'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> backtrack(board,i,j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c=<span class="string">'1'</span>; c&lt;=<span class="string">'9'</span>; c++)&#123;</span><br><span class="line">            <span class="comment">// 如果遇到不合法的数字，就跳过</span></span><br><span class="line">            <span class="keyword">if</span>(!isValid(board,i,j,c))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在该位置上做出一个选择，填入某个字符</span></span><br><span class="line">            board[i][j] = c;</span><br><span class="line">            <span class="comment">// 如果找到一个可行解，立即结束</span></span><br><span class="line">            <span class="keyword">if</span>(backtrack(board,i,j+<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否则，撤销上次选择。进入下一个循环，做另外一个选择</span></span><br><span class="line">            board[i][j] = <span class="string">'.'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 穷举完 1~9，依然没有找到可行解，此路不通,九宫格填写失败，返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断某个格子填入某个字符c是否合法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> column, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; i++)&#123;</span><br><span class="line">            <span class="comment">// 判断行是否存在重复</span></span><br><span class="line">            <span class="keyword">if</span>(board[row][i] == c) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 判断列是否存在重复</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][column] == c) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 判断 3 x 3 方框是否存在重复</span></span><br><span class="line">            <span class="keyword">if</span>(board[(row/<span class="number">3</span>)*<span class="number">3</span>+i/<span class="number">3</span>][(column/<span class="number">3</span>)*<span class="number">3</span>+i%<span class="number">3</span>] == c) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 以上都没有，则可以填入该字符</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="7-待解决难题"><a href="#7-待解决难题" class="headerlink" title="7  待解决难题"></a>7  待解决难题</h1><h2 id="7-1-修塔游戏"><a href="#7-1-修塔游戏" class="headerlink" title="7.1 修塔游戏"></a>7.1 修塔游戏</h2><p><strong>题目描述</strong></p>
<p>小招正在玩一款修塔游戏：系统中有n座高塔，每座高塔由若干个高度相同的方块堆砌而成。修塔游戏的规则为：</p>
<ol>
<li>每次从最高塔的塔尖拿走一个方块</li>
<li>每次在最低塔的塔尖堆砌一个方块</li>
</ol>
<p>小招每次只能完成上述两个动作中的其中之一。游戏的目标是使n座高塔中至少有k座高塔的高度相同，请问小招最少需要多少次才能完成游戏。</p>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    J Len
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://j-len.github.io/2020/07/18/BFS+DFS+%E5%9B%9E%E6%BA%AF/" title="BFS+DFS">https://j-len.github.io/2020/07/18/BFS+DFS+%E5%9B%9E%E6%BA%AF/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/07/13/%E6%8F%90%E5%89%8D%E6%89%B9%E9%9D%A2%E7%BB%8F/" rel="next" title="提前批面经">
                <i class="fa fa-chevron-left"></i> 提前批面经
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/07/18/Java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="prev" title="Java正则表达式">
                Java正则表达式 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">J Len</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/J-Len" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="853408782@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-BFS（宽度优先搜索）"><span class="nav-number">1.</span> <span class="nav-text">1  BFS（宽度优先搜索）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-算法框架"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 算法框架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-二叉树的最小高度-Leetcode-111"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 二叉树的最小高度  Leetcode-111</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Q1-为什么-BFS-可以找到最短距离，DFS-不行吗？"><span class="nav-number">1.2.1.</span> <span class="nav-text">Q1 为什么 BFS 可以找到最短距离，DFS 不行吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q2-既然-BFS-那么好，为啥-DFS-还要存在？"><span class="nav-number">1.2.2.</span> <span class="nav-text">Q2 既然 BFS 那么好，为啥 DFS 还要存在？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-解开密码锁的最少次数-Leetcode-752"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 解开密码锁的最少次数  Leetcode-752</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-机器人的运动范围-面试题-13"><span class="nav-number">1.4.</span> <span class="nav-text">1.4 机器人的运动范围  面试题-13</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-双向BFS优化"><span class="nav-number">1.5.</span> <span class="nav-text">1.5 双向BFS优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-6-图的多源BFS"><span class="nav-number">1.6.</span> <span class="nav-text">1.6 图的多源BFS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-1-地图分析-Leetcode-1162"><span class="nav-number">1.6.1.</span> <span class="nav-text">1.6.1 地图分析  Leetcode-1162</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-2-岛屿的最大面积-Leetcode-695"><span class="nav-number">1.6.2.</span> <span class="nav-text">1.6.2 岛屿的最大面积  Leetcode-695</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-3-被围绕的区域-Leetcode-130"><span class="nav-number">1.6.3.</span> <span class="nav-text">1.6.3 被围绕的区域  Leetcode-130</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-4-腐烂的橘子-Leetcode-994"><span class="nav-number">1.6.4.</span> <span class="nav-text">1.6.4 腐烂的橘子  Leetcode-994</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-5-地图分析"><span class="nav-number">1.6.5.</span> <span class="nav-text">1.6.5 地图分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-6-岛屿数量-Leetcode-200"><span class="nav-number">1.6.6.</span> <span class="nav-text">1.6.6 岛屿数量  Leetcode-200</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-7-完全平方数-Leetcode-279"><span class="nav-number">1.7.</span> <span class="nav-text">1.7 完全平方数  Leetcode-279</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-8-零钱兑换-Leetcode-322"><span class="nav-number">1.8.</span> <span class="nav-text">1.8 零钱兑换  Leetcode-322</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-9-二叉树的右视图-Leetcode-199"><span class="nav-number">1.9.</span> <span class="nav-text">1.9 二叉树的右视图  Leetcode-199</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-10-迷宫最短路径-华为机试题"><span class="nav-number">1.10.</span> <span class="nav-text">1.10 迷宫最短路径  华为机试题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-11-跳跃游戏II-Leetcode-45（Hard）"><span class="nav-number">1.11.</span> <span class="nav-text">1.11 跳跃游戏II  Leetcode-45（Hard）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-DFS（深度优先搜索）"><span class="nav-number">2.</span> <span class="nav-text">2  DFS（深度优先搜索）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-机器人的运动范围-面试题-13"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 机器人的运动范围  面试题-13</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-岛屿的最大面积-Leetcode-695"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 岛屿的最大面积  Leetcode-695</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#算法1：递归-深度优先遍历"><span class="nav-number">2.2.0.1.</span> <span class="nav-text">算法1：递归 + 深度优先遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#算法2：栈-深度优先遍历"><span class="nav-number">2.2.0.2.</span> <span class="nav-text">算法2：栈 + 深度优先遍历</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-岛屿数量-Leetcode-200"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 岛屿数量  Leetcode-200</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-单词搜索-Leetcode-79（Medium）"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 单词搜索  Leetcode-79（Medium）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-二叉树的右视图-Leetcode-199"><span class="nav-number">2.5.</span> <span class="nav-text">2.5 二叉树的右视图  Leetcode-199</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-6-24点游戏-Leetcode-679"><span class="nav-number">2.6.</span> <span class="nav-text">2.6 24点游戏  Leetcode-679</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-回溯"><span class="nav-number">3.</span> <span class="nav-text">4  回溯</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-24点游戏-Leetcode-679"><span class="nav-number">3.1.</span> <span class="nav-text">4.1 24点游戏  Leetcode-679</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-数独-Leetcode-37（Hard）"><span class="nav-number">3.2.</span> <span class="nav-text">4.2 数独  Leetcode-37（Hard）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-待解决难题"><span class="nav-number">4.</span> <span class="nav-text">7  待解决难题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-修塔游戏"><span class="nav-number">4.1.</span> <span class="nav-text">7.1 修塔游戏</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">J-Len</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
